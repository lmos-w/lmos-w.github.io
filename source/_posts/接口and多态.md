---
title: 接口and多态
date: 2020-01-06 22:41:24
tags: [interface,多态]
categories: Java
---
就在Java学习接口和多态时的一些笔记！
<!--more-->
#### 什么是接口？
- 接口就是多个类的公共规范。

- 接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。
***
##### 如何定义一个接口的格式：
```
public interface 接口名称 {
    // 接口内容
}
```
**备注：**换成了关键字interface之后，编译生成的字节码文件仍然是：.java --> .class。
***
#### 如果是Java 7，那么接口中可以包含的内容有：
- 常量
- 抽象方法

#### 如果是Java 8，还可以额外包含有：
- 默认方法
- 静态方法

#### 如果是Java 9，还可以额外包含有：
- 私有方法
***
#### 接口使用步骤：
- 1、接口不能直接使用，必须有一个“实现类”来“实现”该接口。
 - **[格式]：**
```
public class 实现类名称 implements 接口名称 {
    // ...
}
```

- 2、接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。
 - **[实现]：**去掉abstract关键字，加上方法体大括号。


- 3、创建实现类的对象，进行使用。

##### 注意事项：
如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。
***
- 接口的默认方法，可以通过接口实现类对象，直接调用。

- 接口的默认方法，也可以被接口实现类进行覆盖重写。
***
- **[注意事项]：**不能通过接口实现类的对象来调用接口当中的静态方法。

- **[正确用法]：**通过接口名称，直接调用其中的静态方法。
- **[格式]：**接口名称.静态方法名(参数);
***
#### 在任何版本的Java中，接口都能定义抽象方法。
**[格式]：**
public abstract 返回值类型 方法名称(参数列表);

**[注意事项]：**
- 接口当中的抽象方法，修饰符必须是**[两个固定]**的关键字：public abstract

- 这两个关键字修饰符，可以选择性地省略。**(不推荐)**

- 方法的三要素，可以随意定义。
***
>接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。
从效果上看，这其实就是接口的【常量】。

- **[格式]**：
public static final 数据类型 常量名称 = 数据值;

- **[备注]**：
一旦使用final关键字进行修饰，说明不可改变。

**注意事项**：
- 接口当中的常量，可以省略public static final，注意：不写也照样是这样。

- 接口当中的常量，必须进行赋值；不能不赋值。

- 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。**（推荐命名规则）**
***
#### 从Java 8开始，接口里允许定义默认方法。
- **[格式]：**
```
public default 返回值类型 方法名称(参数列表) {
    方法体
}
```
- **[备注]**：接口当中的默认方法，可以解决接口升级的问题。
***
##### 问题描述：
我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。
但是这个共有方法不应该让实现类使用，应该是私有化的。

##### 解决方案：
从Java 9开始，接口当中允许定义私有方法。
- 普通私有方法，解决多个默认方法之间重复代码问题

 ```
private 返回值类型 方法名称(参数列表) {
    方法体
}
```
- 静态私有方法，解决多个静态方法之间重复代码问题
```
private static 返回值类型 方法名称(参数列表) {
    方法体
}
```
***
从Java 8开始，接口当中允许定义**静态方法**。
```
public static 返回值类型 方法名称(参数列表) {
    方法体
}
```
**[提示]：**就是将abstract或者default换成static即可，带上方法体。
***
**使用接口的时候，需要注意：**

- 1.接口是没有静态代码块或者构造方法的。

- 2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
```
public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {
    // 覆盖重写所有抽象方法
}
```

- 3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。

- 4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。

- 5.如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。

- 6.一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。
***
- 1.类与类之间是单继承的。直接父类只有一个。

- 2.类与接口之间是多实现的。一个类可以实现多个接口。

- 3.接口与接口之间是多继承的。

**[注意事项]：**

- 1.多个父接口当中的抽象方法如果重复，没关系。

- 2.多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。
***
#### 代码当中体现多态性，其实就是一句话：父类引用指向子类对象。

**[格式：]**
- 父类名称 对象名 = new 子类名称();

- 接口名称 对象名 = new 实现类名称();
***
#### 访问成员[变量]的两种方式：

- 1.直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。

- 2.间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。
***
**在多态的代码当中，成员[方法]的访问规则是：**

    看new的是谁，就优先用谁，没有则向上找。

**口诀：**编译看左边，运行看右边。

**对比一下：**

- 成员**变量**：编译看左边，运行还看左边。

- 成员**方法**：编译看左边，运行看右边。
***
向上转型一定是安全的，没有问题的，正确的。

但是也有一个**弊端：**
对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。

**解决方案：**用对象的向下转型【还原】。
***
#### 如何才能知道一个父类引用的对象，本来是什么子类？

**格式：**
对象 instanceof 类名称

这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。
***
