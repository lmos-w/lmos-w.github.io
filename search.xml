<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java文件读写</title>
    <url>/2019/11/18/Java%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/13863123-3b31b9635a45a269.jpg" alt> <img src="http://upload-images.jianshu.io/upload_images/13863123-e669017cd996500b.jpg" alt></p><p><strong>IO 流</strong></p><ol>
<li>IO 流：用于处理设备上的数据。</li>
</ol><p>设备：硬盘，内存，键盘录入。</p><ol start="2">
<li>IO 有具体的分类：</li>
</ol><p>（1）根据处理的数据类型不同：字节流和字符流。</p><p>（2）根据流向不同：输入流和输出流。</p><p>字符流的由来：</p><p>因为文件编码的不同，而有了对字符进行高效操作的字符流对象。</p><p>原理：其实就是基于字节流读取字节时，去查了指定的码表。</p><a id="more"></a>










<p>字节流和字符流的区别：</p>
<p>（1）字节流读取的时候，读到一个字节就返回一个字节。</p>
<p>字符流使用了字节流读到一个或多个字节（中文对应的字节数是两个，在 UTF-8 码表中是 3 个字节）时，先去查指定的编码表，将查到的字符返回。</p>
<p><strong>（2）字节流可以处理所有类型数据，如 MP3，图片，avi。而字符流只能处理字符数据。</strong></p>
<p><strong>结论：只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都要用字节流。</strong></p>
<p>IO 的体系，所具备的基本功能就有两个：读和写。</p>
<ol>
<li><p>字节流：InputStream(读)，OutputStream（写）。</p>
</li>
<li><p>字符流：Reader（读），Writer（写）。</p>
</li>
</ol>
<p><strong>一. 字符流:</strong></p>
<p>Reader  </p>
<p>|–InputStreamReader  </p>
<p>　　 |–FileReader: 专门用于处理文件的字符读取流对象。  </p>
<p>Writer</p>
<p> |–OutputStreamWriter  </p>
<p>　　 |–FileWriter: 专门用于处理文件的字符写入流对象</p>
<p>Reader 中的常见的方法：  </p>
<ol>
<li>int read()：  </li>
</ol>
<p>　　 读取一个字符。返回的是读到的那个字符。如果读到流的末尾，返回 - 1.  </p>
<p>*<em>2. int read(char[])：    *</em></p>
<p>**　　将读到的字符存入指定的数组中，返回的是读到的字符个数，也就是往数组里装的元素的个数。如果读到流的末尾，返回 - 1.  **</p>
<ol start="3">
<li>close():    </li>
</ol>
<p>　　读取字符其实用的是 window 系统的功能，就希望使用完毕后，进行资源的释放。</p>
<p>Writer 中的常见的方法：  </p>
<p>1，write(ch): 将一个字符写入到流中。  </p>
<p>2，write(char[]): 将一个字符数组写入到流中。</p>
<p>3，write(String): 将一个字符串写入到流中。  </p>
<p>4，flush(): 刷新流，将流中的数据刷新到目的地中，流还存在。  </p>
<p>5，close(): 关闭资源：在关闭前会先调用 flush()，刷新流中的数据去目的地。然流关闭。</p>
<p>FileWriter:  </p>
<p>该类没有特有的方法。只有自己的构造函数。  </p>
<p>该类特点在于，  </p>
<p>1，用于处理文本文件。  </p>
<p>2，该类中有默认的编码表，  </p>
<p>3，该类中有临时缓冲。</p>
<p>构造函数：在写入流对象初始化时，必须要有一个存储数据的目的地。</p>
<p>  FileWriter(String filename):   该构造函数做了什么事情呢？  </p>
<p>1，调用系统资源。  </p>
<p>2，在指定位置，创建一个文件。  </p>
<p> 注意：如果该文件已存在，将会被覆盖。  </p>
<p>FileWriter(String filename,boolean append):  </p>
<p> 　　该构造函数：当传入的 boolean 类型值为 true 时，会在指定文件末尾处进行数据的续写。</p>
<p>FileReader：  </p>
<p>1，用于读取文本文件的流对象。  </p>
<p>2，用于关联文本文件。</p>
<p> 构造函数：在读取流对象初始化的时候，必须要指定一个被读取的文件。    </p>
<p>如果该文件不存在会发生 FileNotFoundException.  </p>
<p>FileReader(String filename);</p>
<p>对于读取或者写入流对象的构造函数，以及读写方法，还有刷新关闭功能都会抛出 IOException 或其子类。</p>
<p>所以都要进行处理，或者 throws 抛出，或者 try、catch 处理。</p>
<p>*<em>另一个小细节：  *</em></p>
<p><strong>当指定绝对路径时，定义目录分隔符有两种方式：</strong></p>
<p><strong>1，反斜线 但是一定要写两个。\  new FileWriter(“c:\demo.txt”);</strong></p>
<p><strong>2，斜线  /  写一个即可。 new FileWriter(“c:/demo.txt”);</strong></p>
<p><strong>字符流的缓冲区：</strong></p>
<p>缓冲区的出现提高了对流的操作效率。</p>
<p>原理：其实就是将数组进行封装。</p>
<p>对应的对象：</p>
<p>BufferedWriter：</p>
<p>　　特有方法：</p>
<p><strong>newLine（）：跨平台的换行符。</strong></p>
<p>BufferedReader：</p>
<p>　　特有方法：</p>
<p><strong>readLine（）：一次读一行，到行标记时，将行标记之前的字符数据作为字符串返回。当读到末尾时，返回 null。</strong></p>
<p>使用缓冲区对象时，要明确，缓冲的存在是为了增强流的功能而存在，所以在简历缓冲区对象时，要现有流对象存在。</p>
<p>其实缓冲内部就是在使用流对象的方法，只不过加入了数组对数据进行了临时存储，为了提高操作数据的效率。</p>
<p>代码上的体现:</p>
<p><strong>写入缓冲区对象：</strong></p>
<p>// 建立缓冲区对象必须把流对象作为参数传递给缓冲区的构造函数。</p>
<p>BufferedWriter bw=new BufferedWriter（new FileWriter（“abc.txt”））；</p>
<p>bw.write(“abce”);// 将数据写入到了缓冲区。</p>
<p>bw.flush();// 对缓冲区的数据进行刷新。将数据刷到目的地中。</p>
<p>bw.close();// 关闭缓冲区，其实关闭的是被包装在内部的流对象。</p>
<p><strong>读取缓冲区对象：</strong></p>
<p>** 二. 字节流:**</p>
<p>抽象基类: InputStream，OutputStream。</p>
<p>字节流可以操作任何数据。</p>
<p>注意：字符流使用的数组是字符数组，char[] chs ；</p>
<p>　　　字节流使用的数组是字节数组，byte[] bt ；</p>
<p>FileOutputStream fos=new FileOutputStream(“a.txt”)；</p>
<p>fos.write(“abcde”); // 直接将数据写入到了目的地。</p>
<p>fos.close();// 只关闭资源。</p>
<p>FileInputSteam fls=new FileInputStream(“a.txt”);</p>
<p>//fis.available();// 获取关联的文件字节数。如果文件体积不大，可以这样操作。</p>
<p>byte[]buf=new byte[fis.available()];// 创建一个刚刚好的缓冲区。// 但是这有一个弊端，就是文件过大，大小超出 Jvm 的内容空间时，会内存溢出。</p>
<p>fis.read(buf);</p>
<p>System.out.println(new String(buf));</p>
<p>例子:</p>
<p>　　需求: copy 一个图片。</p>
<p>BufferedInputStream bufis=new BufferedInputStream(new FileInputStream(“1.jpg”));</p>
<p>BufferedOutputStream bufos=new BufferedOutputStream(new FileOutputStream(“2.jpg”));</p>
<p>int by=0;</p>
<p>while(by=bufis.read()!=-1){</p>
<p>　　bufos.write(by);</p>
<p>　　bufos.newLine();</p>
<p>}</p>
<p>bufis.close();</p>
<p>bufos.close();</p>
<p><strong>小结:</strong></p>
<p>目前学习的流对象:</p>
<p>字符流: FileReader  FileWriter  BuffereedReader  BufferedWriter</p>
<p>字节流: FileInputStream  FileOutputStream   BufferedInputStream  BufferedOutputStream</p>
<p>补充：</p>
<ol>
<li>字节流的 read（）方法读取的是一个字节。为什么返回的不是 byte 类型，而是 int 类型呢？</li>
</ol>
<p>因为 read 方法读到末尾时返回的是 - 1，而在所操作的数据中很容易出现连续多个 1 的情况，而连续读到 8 个 1，就是 - 1，导致读取会提前停止。所以将读到的一个字节提升为一个 int 类型的数值，但是只保留原字节，并在剩余二进制位补 0。</p>
<p>具体操作是：byte&amp;255 or byte&amp;0xff</p>
<ol start="2">
<li>对于 write 方法，可以一次写入一个字节，但接收的是一个 int 类型数值。只写入该 int 类型的数值的最低一个字节（8 位）。</li>
</ol>
<p>简单说：<strong>read 方法对读到的数据进行提升，write 对操作的数据进行转换。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>File</tag>
      </tags>
  </entry>
  <entry>
    <title>DataURL, Blob, File, Image 之间的关系与转换</title>
    <url>/2019/11/18/DataURL-Blob-File-Image-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>使用前景：</p>
<p><strong><em>移动端上传拍照图片太大，使用 canvas 压缩后 base64=&gt;blob 二进制表单文件 =&gt;ajax-POST 上传</em></strong> <a id="more"></a><img src="https://oscimg.oschina.net/oscnet/45bb5cc130ba93fa7d2365fb81304c75f9a.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// canvas转dataURL：canvas对象、转换格式、图像品质</span><br><span class="line">function canvasToDataURL(canvas, format, quality) &#123;</span><br><span class="line">    return canvas.toDataURL(format||&apos;image/jpeg&apos;, quality||1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// DataURL转canvas</span><br><span class="line">function dataURLToCanvas(dataurl, cb)&#123;</span><br><span class="line">    var canvas = document.createElement(&apos;CANVAS&apos;);</span><br><span class="line">    var ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.onload = function()&#123;</span><br><span class="line">        canvas.width = img.width;</span><br><span class="line">        canvas.height = img.height;</span><br><span class="line">        ctx.drawImage(img, 0, 0);</span><br><span class="line">        cb(canvas);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = dataurl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// image转canvas：图片地址</span><br><span class="line">function imageToCanvas(src, cb)&#123;</span><br><span class="line">    var canvas = document.createElement(&apos;CANVAS&apos;);</span><br><span class="line">    var ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.src = src;</span><br><span class="line">    img.onload = function ()&#123;</span><br><span class="line">        canvas.width = img.width;</span><br><span class="line">        canvas.height = img.height;</span><br><span class="line">        ctx.drawImage(img, 0, 0);</span><br><span class="line">        cb(canvas);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// canvas转image</span><br><span class="line">    function canvasToImage(canvas)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">        img.src = canvas.toDataURL(&apos;image/jpeg&apos;, 1.0);</span><br><span class="line">        return img;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// File/Blob对象转DataURL</span><br><span class="line">    function fileOrBlobToDataURL(obj, cb)&#123;</span><br><span class="line">        var a = new FileReader();</span><br><span class="line">        a.readAsDataURL(obj);</span><br><span class="line">        a.onload = function (e)&#123;</span><br><span class="line">            cb(e.target.result);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// DataURL转Blob对象</span><br><span class="line">    function dataURLToBlob(dataurl)&#123;</span><br><span class="line">        var arr = dataurl.split(&apos;,&apos;);</span><br><span class="line">        var mime = arr[0].match(/:(.*?);/)[1];</span><br><span class="line">        var bstr = atob(arr[1]);</span><br><span class="line">        var n = bstr.length;</span><br><span class="line">        var u8arr = new Uint8Array(n);</span><br><span class="line">        while(n--)&#123;</span><br><span class="line">            u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Blob([u8arr], &#123;type:mime&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Blob转image</span><br><span class="line">    function blobToImage(blob, cb)&#123;</span><br><span class="line">        fileOrBlobToDataURL(blob, function (dataurl)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">            img.src = dataurl;</span><br><span class="line">            cb(img);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// image转Blob</span><br><span class="line">    function imageToBlob(src, cb)&#123;</span><br><span class="line">        imageToCanvas(src, function (canvas)&#123;</span><br><span class="line">            cb(dataURLToBlob(canvasToDataURL(canvas)));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Blob转canvas</span><br><span class="line">    function BlobToCanvas(blob, cb)&#123;</span><br><span class="line">        fileOrBlobToDataURL(blob, function (dataurl)&#123;</span><br><span class="line">            dataURLToCanvas(dataurl, cb);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// canvas转Blob</span><br><span class="line">function canvasToBlob(canvas, cb)&#123;</span><br><span class="line">	cb(dataURLToBlob(canvasToDataURL(canvas)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// image转dataURL</span><br><span class="line">function imageToDataURL(src, cb)&#123;</span><br><span class="line">	imageToCanvas(src, function (canvas)&#123;</span><br><span class="line">		cb(canvasToDataURL(canvas));</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// dataURL转image，这个不需要转，直接给了src就能用</span><br><span class="line">function dataURLToImage(dataurl)&#123;</span><br><span class="line">	var img = new Image();</span><br><span class="line">	img.src = d;</span><br><span class="line">	return img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Blob</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p>hello world!!</p>
]]></content>
  </entry>
</search>
