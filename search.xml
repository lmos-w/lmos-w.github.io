<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue 组件内容分发（slot）</title>
    <url>/2019/11/19/Vue-%E7%BB%84%E4%BB%B6%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%EF%BC%88slot%EF%BC%89/</url>
    <content><![CDATA[<p>在实际项目开发当中，时常会把父组件的内容与子组件自己的模板混合起来使用。而这样的一个过程在 Vue 中被称为<strong>内容分发</strong>。也常常被称为<strong><code>slot</code>（插槽）</strong>。其主要参照了当前 <a href="//github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md">Web Components 规范草案</a>，使用特殊的<code>&lt;slot&gt;</code>元素作为原始内容的插槽。今天主要来学习如何在 Vue 中使用<code>slot</code>的功能。</p><a id="more"></a>
<h2 id="先简单的了解一个概念"><a href="#先简单的了解一个概念" class="headerlink" title="先简单的了解一个概念"></a>先简单的了解一个概念</h2><p>在深入理解 Vue 的<code>slot</code>之前，先来简单的了解一个有关于<code>slot</code>的概念，便于后续的学习和理解。</p>
<p>前面也说过了，Vue 中的<code>slot</code>源于 Web Components 规范草案，也被称之为插槽，是组件的一块 HTML 模板，而这块模板显示不显示，以及怎么显示由父组件来决定。那么，Vue 中一个<code>slot</code>最核心的两个问题就出来了：</p>
<ul>
<li><strong>显示不显示</strong></li>
<li><strong>怎么显示</strong></li>
</ul>
<p>由于<code>slot</code>是一块模板，因此对于任何一个组件，从模板种类的角度来分，共实都可分为<strong>非插槽模板</strong>和<strong>插槽模板</strong>。其中非插槽模板指的是 HTML 模板（也就是 HTML 的一些元素，比如<code>div</code>、<code>span</code>等构成的），其显与否及怎么显示完全由插件自身控制；但插槽模板（也就是<code>slot</code>）是一个空壳子，它显示与否以及怎么显示完全是由<strong>父组件</strong>来控制。不过，<strong>插槽显示的位置由子组件自身决定，<code>slot</code>写在组件<code>template</code>的哪块，父组件传过来的模板将来就显示在哪块</strong>。</p>
<h2 id="Vue-的编译作用域"><a href="#Vue-的编译作用域" class="headerlink" title="Vue 的编译作用域"></a>Vue 的编译作用域</h2><p>简单的了解了<code>slot</code>中的基本概念，从基本概念中可以获知，使用<code>slot</code>会涉及 Vue 的模板，而 Vue 的模板在渲染成 UI 之前是有一个编译过程的，也会存在模板<strong>编译作用域</strong>一说。理解清楚这部分内容，也更有助于我们理解<code>slot</code>，所以花点时间先简单的理解一下 Vue 的编译作用域。</p>
<p>在前面的《<a href="//www.w3cplus.com/vue/vue-instances-and-life-cycles.html">Vue 实例和生命周期</a>》一文中，我们了解了 Vue 的生命周期相关的知识点，此处不再阐述，上张介绍 Vue 生命周期的图：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1711/vue-instances-and-life-cycles-8.png" alt></p>
<p>碰到是否有<code>template</code>选项时，会询问是否要对<code>template</code>进行编译：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1803/vue-slot-1.png" alt></p>
<p>在<code>template</code>编译（渲染成 UI）有一个过程。模板通过编译生成 AST，再由 AST 生成 Vue 的渲染函数，渲染函数结合数据生成 Virtual DOM 树，对 Virtual DOM 进行<code>diff</code>和<code>patch</code>后生成新的 UI。将上图细化一下，也就是<code>template</code>编译的过程如下图所示：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1710/vue-template-9.jpg" alt></p>
<p>在深入一点，如下：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1710/vue-template-10.png" alt></p>
<blockquote>
<p>有关于 Vue 中<code>template</code>的渲染的详细过程，可以阅读《<a href="//www.w3cplus.com/vue/vue-template.html">Vue 的模板</a>》一文。</p>
</blockquote>
<p>简理的理解就是 Vue 中的<code>template</code>编译成浏览器可识的过程会经过不少的过程。言外之意，最终在浏览器中呈现的并不是<code>&lt;template&gt;</code>，而是会解析成标准的 HTML，然后将组件的标签替换为对应的 HTML 片段。用个小示例来举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;myComponent&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;button @click=&quot;show&quot;&gt;Show Message&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">    template: &apos;#myComponent&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message: &apos;我是一个Vue组件!&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        show: function () &#123;</span><br><span class="line">            alert(this.message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Vue 将会通过其自身的编译机制（如前图所示的过程），将<code>&lt;my-component&gt;</code>编译成让浏览器可以识别的 HTML 代码。可以借助浏览器开发者工具一探究竟：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1803/vue-slot-2.png" alt></p>
<p>我的理解是这样的。上面的示例通过<code>new Vue()</code>创建一下人 Vue 的实例，并且将这个实例挂载到<code>div#app</code>的元素下，然后把组件<code>&lt;my-component&gt;</code>编译成 HTML，最终渲染所需要的 UI 效果。继续用张图来描述这个过程，一图胜过千言万语嘛。</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1803/vue-slot-3.png" alt></p>
<p>我们要说的是模板编译的作用域，在 Vue 中，组件是有一个作用域的：<strong>组件模板（<code>&lt;template&gt;</code>）</strong>内的就是组件作用域，而其之外的就不是组件的作用域了，比如上面的示例，<code>my-component</code>组件的作用域就是下面这部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template id=&quot;myComponent&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;button @click=&quot;show&quot;&gt;Show Message&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>组件的模板是在其作用域内编译的，因此组件选项对象中的<code>data</code>也是在组件模板中使用的。如果我们在前面的示例中的 Vue 实例的组件<code>my-component</code>中同时追加一个<code>display</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">    template: &apos;#myComponent&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message: &apos;我是一个Vue组件!&apos;,</span><br><span class="line">            display: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        show: function () &#123;</span><br><span class="line">            alert(this.message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            display: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后在<code>&lt;my-component&gt;</code>中使用指令<code>v-show=&quot;display&quot;</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;my-component v-show=&quot;display&quot;&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>试问，此时<code>display</code>是来源于 Vue 实例，还是<code>my-component</code>组件呢？答案很简单：<strong><code>display</code>来源于 Vue 实例</strong>。也就是说，在 Vue 中组件的作用域是独立的：</p>
<blockquote>
<p><strong>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。</strong></p>
</blockquote>
<p>通俗地讲，在子组件中定义的数据，只能用在子组件的模板。在父组件中定义的数据，只能用在父组件的模板。如果父组件的数据要在子组件中使用，则需要子组件定义<code>props</code>。有关于这方面的内容可以阅读：</p>
<ul>
<li>《<a href="//www.w3cplus.com/vue/component-data-and-props-part1.html">组件数据传递</a>》</li>
<li>《<a href="//www.w3cplus.com/vue/component-data-and-props-part2.html">实现组件数据的双向绑定</a>》</li>
<li>《<a href="//www.w3cplus.com/vue/component-data-and-props-part3.html">不同场景下组件间的数据通讯</a>》</li>
</ul>
<p>简单的了解了 Vue 编译的作用域之后，咱们接着回到我们今天要聊的主题，Vue 的<code>slot</code>。</p>
<h2 id="slot大致用法"><a href="#slot大致用法" class="headerlink" title="slot大致用法"></a><code>slot</code>大致用法</h2><p>先来简单的看一下 Vue 中的<code>slot</code>的使用方法。比如我们有一个类似<code>alert</code>的小组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;alert&gt;&lt;/alert&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;alert&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;alert info&quot;&gt;</span><br><span class="line">        &lt;button class=&quot;close&quot;&gt;×&lt;/button&gt;</span><br><span class="line">        &lt;slot&gt;This is alert box!&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;alert&apos;, &#123;</span><br><span class="line">    template: &apos;#alert&apos;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的代码在<code>alert</code>组件的模板中指定了一个<code>&lt;slot&gt;</code>元素，并且在该元素中放置了一个默认内容 “This is alert box!”。在调用<code>alert</code>组件时，并没有向该组件分发任何内容，这个时候运行的结果如下：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1803/vue-slot-5.png" alt></p>
<p>从上面的效果中可以得知：<strong>如果父组件未向模板中分发内容（插入内容），则显示插槽中默认内容（前提是<code>slot</code>中设置了默认内容）</strong>。</p>
<p>接下来，在上面的示例上，做小小的修改，在<code>&lt;alert&gt;</code>使用的时候，插入你想要的内容（也就是指父组件向模板分发内容）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;alert&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;Hello W3cplus!&lt;/h2&gt;</span><br><span class="line">            &lt;p&gt;欢迎您来到w3cplus.com！&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/alert&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码得到的效果是：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1803/vue-slot-6.png" alt></p>
<p>从代码运行的结果可以得知：<strong>父组件给模板分发了内容，则分发的内容会替换<code>slot</code>标签</strong>。除此之外，假设<strong>模板中未设置插槽，父组件依旧向其分发了内容，但最终任何分发的内容都不会显示</strong>。比如下图所示：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1803/vue-slot-7.png" alt></p>
<p>在介绍编译作用域时，了解到，<strong>父组件的内容是在父组件作用域编译，子组件的内容是在子组件作用域编译</strong>。而 Vue 的<code>slot</code>一般用在父组件向子组件分发内容，该内容的编译作用域名为父组件作用域。</p>
<p>继续拿上面的<code>alert</code>组件来举例。在我们的<code>alert</code>组件中，很多时候有多种样式风格，除了<code>info</code>之外，还有<code>success</code>、<code>danger</code>和<code>warning</code>之类。我们可以在父组件的编译时绑定<code>status</code>状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;alert v-for=&quot;statu in status&quot; :status=statu&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;&#123;&#123; statu &#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;p&gt;欢迎您来到w3cplus.com！&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/alert&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;alert&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;alert&quot; :class=&quot;[alertStatus]&quot; v-show=&quot;isShow&quot;&gt;</span><br><span class="line">        &lt;button class=&quot;close&quot; @click=&quot;close&quot;&gt;×&lt;/button&gt;</span><br><span class="line">        &lt;slot&gt;This is alert box!&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;alert&apos;, &#123;</span><br><span class="line">    template: &apos;#alert&apos;,</span><br><span class="line">    props: [&apos;status&apos;],</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            isShow: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        alertStatus: function () &#123;</span><br><span class="line">            return this.status</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        close: function () &#123;</span><br><span class="line">            this.isShow = !this.isShow</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            status: [&apos;info&apos;, &apos;success&apos;, &apos;danger&apos;, &apos;warning&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最终效果如下：</p>
<h2 id="slot-分类"><a href="#slot-分类" class="headerlink" title="slot 分类"></a>slot 分类</h2><p>在 Vue 中，<code>slot</code>也分多种，从 Vue 的官网中可以获知，其主要分为：<strong>单个插槽</strong>、<strong>具名插槽</strong>和<strong>作用域插槽</strong>三种。接下来我们借助 <a href="//www.w3cplus.com/vue/vue-modal-component.html"><code>modal</code>组件</a>为例，看看 Vue 中的这几种插槽怎么使用。</p>
<p>Web 中常见的<code>modal</code>弹框外形长得大致都如下图这样：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1801/modal-vue-2.png" alt></p>
<h3 id="单个插槽"><a href="#单个插槽" class="headerlink" title="单个插槽"></a>单个插槽</h3><p>在介绍<code>slot</code>大致使用方法的一节中，已经知道了，如果子组件<code>template</code>中没有包含任何一个<code>&lt;slot&gt;</code>时，就算父组件分发再多的内容也将会被<strong>丢弃</strong>。只有子组件模板只要有一个没有属性的<code>slot</code>（因为在模板中可以有多个带属性的<code>slot</code>，后面的内容会介绍），父组件传入的整个内容片段将插入到<code>slot</code>所在的 DOM 位置，并将替换掉<code>slot</code>本身。</p>
<p>最初在<code>&lt;slot&gt;</code>中的任何内容都被视为<strong>备用内容</strong>（也可以在最初的<code>&lt;slot&gt;</code>中不放置任何默认内容）。备用内容在子组件的作用域内编译，并且只有在宿主元素（父组件没有分发任何内容）为空，且没有要插入的内容时才显示备用内容。</p>
<p>如果拿<code>modal</code>来举例，在单个插槽时，整个<code>modal</code>的内容都将需要通过父组件来进行分发。我们可以这样写（可能不太理想，但我们后面会慢慢让她变得更完善）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- modal组件模板 --&gt;</span><br><span class="line">&lt;template id=&quot;modal&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;modal-backdrop&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;modal&quot; @click.stop&gt;</span><br><span class="line">            &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// JavaScript Code</span><br><span class="line">Vue.component(&apos;modal&apos;, &#123;</span><br><span class="line">    template: &apos;#modal&apos;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        close: function (event) &#123;</span><br><span class="line">            this.$emit(&apos;close&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            toggleModal: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        showModal: function () &#123;</span><br><span class="line">            this.toggleModal = true</span><br><span class="line">        &#125;,</span><br><span class="line">        closeModal: function () &#123;</span><br><span class="line">            this.toggleModal = false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在<code>modal</code>组件的<code>template</code>中，只使用了一个<code>&lt;slot&gt;</code>，这个时候在父组件中使用<code>modal</code>组件时，父组件分发的内容就会替换<code>&lt;slot&gt;</code>中的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;modal v-show=&quot;toggleModal&quot; @click=&quot;closeModal&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div class=&quot;modal-header&quot;&gt;</span><br><span class="line">                &lt;div  class=&quot;close rotate&quot; @click=&quot;closeModal&quot;&gt;</span><br><span class="line">                    &lt;i class=&quot;fa-times fa&quot;&gt;&lt;/i&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;h3 class=&quot;modal-title&quot;&gt;Modal Header&lt;/h3&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;modal-body&quot;&gt;</span><br><span class="line">                &lt;h3&gt;Modal Body&lt;/h3&gt;</span><br><span class="line">                &lt;p&gt;Modal body conent...&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;modal-footer&quot;&gt;</span><br><span class="line">                &lt;button class=&quot;btn&quot; @click=&quot;closeModal&quot;&gt;关闭&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/modal&gt;</span><br><span class="line">    &lt;button class=&quot;btn btn-open&quot; @click=&quot;showModal&quot;&gt;Show Modal&lt;/button&gt;</span><br><span class="line">&lt;/div</span><br></pre></td></tr></table></figure>

<p>最终的效果如下：</p>
<p>这样写感觉是不是怪怪的。我也是这么认为的，这只是为了说明单个<code>slot</code>的使用。接下来我们看看具名插槽。</p>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p><code>&lt;slot&gt;</code>可以用一个特殊的属性<code>name</code>来进一步配置父组件如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应<code>slot</code>特性的元素。</p>
<p>仍然可以有一个匿名插槽，它是<strong>默认插槽</strong>，作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。</p>
<p>前面示例写的<code>modal</code>组件使用了一个匿名<code>slot</code>。如果我们使用多个<code>slot</code>时，会让<code>modal</code>组件变得更为灵活。众所周知，对于一个<code>modal</code>组件，其主体结构包括了<code>modal-header</code>、<code>modal-body</code>和<code>modal-footer</code>（当然，很多时候可能不会同时出现，根据需要选择）。那么在定义<code>modal</code>组件的<code>template</code>时，可以使用三个<code>slot</code>，它们的<code>name</code>属性分别命名为<code>header</code>、<code>body</code>和<code>footer</code>。</p>
<p>基于上例，把模板修改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template id=&quot;modal&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;modal-backdrop&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;modal&quot; @click.stop&gt;</span><br><span class="line">            &lt;slot &gt;&lt;/slot&gt;</span><br><span class="line">            &lt;slot &gt;&lt;/slot&gt;</span><br><span class="line">            &lt;slot &gt;&lt;/slot&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>在使用模板的时候：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;modal v-show=&quot;toggleModal&quot; @click=&quot;closeModal&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;modal-header&quot; slot=&quot;header&quot;&gt;</span><br><span class="line">            &lt;div  class=&quot;close rotate&quot; @click=&quot;closeModal&quot;&gt;</span><br><span class="line">            &lt;i class=&quot;fa-times fa&quot;&gt;&lt;/i&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;h3 class=&quot;modal-title&quot;&gt;Modal Header&lt;/h3&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;modal-body&quot; slot=&quot;body&quot;&gt;</span><br><span class="line">            &lt;h3&gt;Modal Body&lt;/h3&gt;</span><br><span class="line">            &lt;p&gt;Modal body conent...&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;modal-footer&quot; slot=&quot;footer&quot;&gt;</span><br><span class="line">            &lt;button class=&quot;btn&quot; @click=&quot;closeModal&quot;&gt;关闭&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/modal&gt;</span><br><span class="line">    &lt;button class=&quot;btn btn-open&quot; @click=&quot;showModal&quot;&gt;Show Modal&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>其他不变，最终的效果如下：</p>
<p>这个时候，你可以根据你的需要，在使用的时候视项目情况去选择，使用具名的插槽。</p>
<blockquote>
<p>在《<a href="//www.w3cplus.com/vue/vue-modal-component.html">使用 Vue 创建 Modal 组件</a>》一文中，也涉及到了<code>slot</code>的内容，现在回过头来看，将会变得更轻松些。</p>
</blockquote>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽是一种特殊类型的插槽，用作一个（能被传递数据的）可重用模板，来代替已经渲染好的元素。</p>
<p>在子组件中，只需将数据传递到插槽，就像你将<code>prop</code>传递给组件一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>在父级中，具有特殊特性 <code>slot-scope</code> 的 <code>&lt;template&gt;</code> 元素必须存在，表示它是作用域插槽的模板。<code>slot-scope</code> 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 <code>prop</code> 对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;child&gt;</span><br><span class="line">        &lt;template slot-scope=&quot;props&quot;&gt;</span><br><span class="line">            &lt;span&gt;hello from parent&lt;/span&gt;</span><br><span class="line">            &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">    &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们渲染上述模板，得到的输出会是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">        &lt;span&gt;hello from parent&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;hello from child&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>在 2.5.0+，<code>slot-scope</code> 能被用在任意元素或组件中而不再局限于 <code>&lt;template&gt;</code></strong>。</p>
</blockquote>
<p>作用域插槽更典型的用例是在列表组件中，允许使用者自定义如何渲染列表的每一项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;my-awesome-list :items=&quot;items&quot;&gt;</span><br><span class="line">    &lt;!-- 作用域插槽也可以是具名的 --&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        slot=&quot;item&quot;</span><br><span class="line">        slot-scope=&quot;props&quot;</span><br><span class="line">        class=&quot;my-fancy-item&quot;&gt;</span><br><span class="line">        &#123;&#123; props.text &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/my-awesome-list&gt;</span><br></pre></td></tr></table></figure>

<p>列表组件的模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;slot</span><br><span class="line">        v-for=&quot;item in items&quot;</span><br><span class="line">        :text=&quot;item.text&quot;&gt;</span><br><span class="line">        &lt;!-- 这里写入备用内容 --&gt;</span><br><span class="line">    &lt;/slot&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p><code>slot-scope</code> 的值实际上是一个可以出现在函数签名参数位置的合法的 JavaScript 表达式。这意味着在受支持的环境 (单文件组件或现代浏览器) 中，您还可以在表达式中使用 ES2015 解构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;child&gt;</span><br><span class="line">    &lt;span slot-scope=&quot;&#123; text &#125;&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/child&gt;</span><br></pre></td></tr></table></figure>

<p>比如下面这个示例：</p>
<p>如果想进一步的了解<code>slot</code>中的作用域插槽，可以阅读《<a href="//www.w3cplus.com/vue/vue-js-scoped-slots.html">Vue 的作用域插槽</a>》一文。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要学习和了解了 Vue 中的插槽<code>&lt;slot&gt;</code>。是一个空壳子，它显示与否以及怎么显示完全是由<strong>父组件</strong>来控制。不过，<strong>插槽显示的位置由子组件自身决定，<code>slot</code>写在组件<code>template</code>的哪块，父组件传过来的模板将来就显示在哪块</strong>。在写一些组件的时候，<code>slot</code>能帮助我们做很多事情，也能让组件可复用性变得更为灵活。</p>
<p><a href="//weibo.com/w3cplus"><img src="https://www.w3cplus.com/sites/default/files/blogs/author/airen.jpg" alt></a></p>
<h3 id="大漠"><a href="#大漠" class="headerlink" title="大漠"></a><a href="//weibo.com/w3cplus">大漠</a></h3><p>常用昵称 “大漠”，W3CPlus 创始人，目前就职于手淘。对 HTML5、CSS3 和 Sass 等前端脚本语言有非常深入的认识和丰富的实践经验，尤其专注对 CSS3 的研究，是国内最早研究和使用 CSS3 技术的一批人。CSS3、Sass 和 Drupal 中国布道者。2014 年出版《<a href="//www.w3cplus.com/book-comment.html">图解 CSS3：核心技术与案例实战</a>》。</p>
<p>如需转载，烦请注明出处：<a href="//www.w3cplus.com/vue/vue-slot.html">https://www.w3cplus.com/vue/vue-slot.html</a><a href="https://www.febshoes.com/category/556" target="_blank" rel="noopener">Air Jordan 89 Shoes</a></p>
<p>如需转载，烦请注明出处：<a href="https://www.w3cplus.com/vue/vue-slot.html" target="_blank" rel="noopener">https://www.w3cplus.com/vue/vue-slot.html</a></p>
<blockquote>
<p><strong>如果文章中有不对之处，烦请各位大神拍正。如果你觉得这篇文章对你有所帮助，<a href="//www.zhi12.com/paycenter/reward/widget?entity=user&id=5491">打个赏，让我有更大的动力去创作</a>。(^_^)。看完了？还不过瘾？点击<a href="//www.zhi12.com/ask/5491/widget">向作者提问！</a></strong></p>
</blockquote>
<p>赏杯咖啡，鼓励他创作更多优质内容！ <a href="//www.zhi12.com/paycenter/reward/widget?entity=user&id=5491"><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1807/shang1.png" alt></a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>slot</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域资源共享 CORS 详解</title>
    <url>/2019/11/19/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB-CORS-%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>CORS 是一个 W3C 标准，全称是 “跨域资源共享”（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出 <a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a>请求，从而克服了 AJAX 只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">同源</a>使用的限制。</p>
<a id="more"></a>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><hr>
<p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。</p>
<p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。</p>
<h2 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h2><hr>
<p>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<blockquote>
<p>（1) 请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP 的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h2 id="三、简单请求"><a href="#三、简单请求" class="headerlink" title="三、简单请求"></a>三、简单请求</h2><hr>
<h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p>
<p>下面是一个例子，浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<h4 id="（1）Access-Control-Allow-Origin"><a href="#（1）Access-Control-Allow-Origin" class="headerlink" title="（1）Access-Control-Allow-Origin"></a><strong>（1）Access-Control-Allow-Origin</strong></h4><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<h4 id="（2）Access-Control-Allow-Credentials"><a href="#（2）Access-Control-Allow-Credentials" class="headerlink" title="（2）Access-Control-Allow-Credentials"></a><strong>（2）Access-Control-Allow-Credentials</strong></h4><p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送 Cookie，删除该字段即可。</p>
<h4 id="（3）Access-Control-Expose-Headers"><a href="#（3）Access-Control-Expose-Headers" class="headerlink" title="（3）Access-Control-Expose-Headers"></a><strong>（3）Access-Control-Expose-Headers</strong></h4><p>该字段可选。CORS 请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到 6 个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>
<h3 id="3-2-withCredentials-属性"><a href="#3-2-withCredentials-属性" class="headerlink" title="3.2 withCredentials 属性"></a>3.2 withCredentials 属性</h3><p>上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
</blockquote>
<p>另一方面，开发者必须在 AJAX 请求中打开<code>withCredentials</code>属性。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。</p>
<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.withCredentials = false;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>需要注意的是，如果要发送 Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的 Cookie。</p>
<h2 id="四、非简单请求"><a href="#四、非简单请求" class="headerlink" title="四、非简单请求"></a>四、非简单请求</h2><hr>
<h3 id="4-1-预检请求"><a href="#4-1-预检请求" class="headerlink" title="4.1 预检请求"></a>4.1 预检请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为 “预检” 请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<p>下面是一段浏览器的 JavaScript 脚本。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var url = &apos;http://api.alice.com/cors&apos;;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;PUT&apos;, url, true);</span><br><span class="line">xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，HTTP 请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个 “预检” 请求，要求服务器确认可以这样请求。下面是这个 “预检” 请求的 HTTP 头信息。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>“预检” 请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，”预检” 请求的头信息包括两个特殊字段。</p>
<h4 id="（1）Access-Control-Request-Method"><a href="#（1）Access-Control-Request-Method" class="headerlink" title="（1）Access-Control-Request-Method"></a><strong>（1）Access-Control-Request-Method</strong></h4><p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是<code>PUT</code>。</p>
<h4 id="（2）Access-Control-Request-Headers"><a href="#（2）Access-Control-Request-Headers" class="headerlink" title="（2）Access-Control-Request-Headers"></a><strong>（2）Access-Control-Request-Headers</strong></h4><p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h3 id="4-2-预检请求的回应"><a href="#4-2-预检请求的回应" class="headerlink" title="4.2 预检请求的回应"></a>4.2 预检请求的回应</h3><p>服务器收到 “预检” 请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的 HTTP 回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果浏览器否定了 “预检” 请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>服务器回应的其他 CORS 相关字段如下。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="（1）Access-Control-Allow-Methods"><a href="#（1）Access-Control-Allow-Methods" class="headerlink" title="（1）Access-Control-Allow-Methods"></a><strong>（1）Access-Control-Allow-Methods</strong></h4><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次 “预检” 请求。</p>
<h4 id="（2）Access-Control-Allow-Headers"><a href="#（2）Access-Control-Allow-Headers" class="headerlink" title="（2）Access-Control-Allow-Headers"></a><strong>（2）Access-Control-Allow-Headers</strong></h4><p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在 “预检” 中请求的字段。</p>
<h4 id="（3）Access-Control-Allow-Credentials"><a href="#（3）Access-Control-Allow-Credentials" class="headerlink" title="（3）Access-Control-Allow-Credentials"></a><strong>（3）Access-Control-Allow-Credentials</strong></h4><p>该字段与简单请求时的含义相同。</p>
<h4 id="（4）Access-Control-Max-Age"><a href="#（4）Access-Control-Max-Age" class="headerlink" title="（4）Access-Control-Max-Age"></a><strong>（4）Access-Control-Max-Age</strong></h4><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。</p>
<h3 id="4-3-浏览器的正常请求和回应"><a href="#4-3-浏览器的正常请求和回应" class="headerlink" title="4.3 浏览器的正常请求和回应"></a>4.3 浏览器的正常请求和回应</h3><p>一旦服务器通过了 “预检” 请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是 “预检” 请求之后，浏览器的正常 CORS 请求。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h2 id="五、与-JSONP-的比较"><a href="#五、与-JSONP-的比较" class="headerlink" title="五、与 JSONP 的比较"></a>五、与 JSONP 的比较</h2><hr>
<p>CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。</p>
<p>JSONP 只支持<code>GET</code>请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存头 Cache-Control 的含义和使用</title>
    <url>/2019/11/18/%E7%BC%93%E5%AD%98%E5%A4%B4-Cache-Control-%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><blockquote>
<p>以下这些头只是限制性的，声明性的作用，没有强制约束力。只是为代理服务器设置了这些头，要求按照规范去做，但是完全可以不按照这个规范做。</p>
</blockquote>
<a id="more"></a>

<ul>
<li><h5 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h5><ul>
<li>public<br>在 http 请求返回的过程当中，在 Cache-Control 设置了 public 值，代表这个 http 请求返回的内容所经过的任何路径当中，包括一些中间的 http 代理服务器以及我们发出请求的客户端浏览器，都可以进行对返回内容的缓存操作：就是把这份数据存在本地，下次直接读这个缓存，不需要到返回这个内容的服务器上面重新进行操作返回内容。可缓存性是指哪些地方可以执行这些缓存。</li>
<li>private<br>只要发起请求的浏览器才可以缓存</li>
<li>no-cache<br>任何节点都不可以缓存。可以在本地服务器缓存，每次发起请求都需要去服务器验证，如果服务器说可以使用缓存，才能使用缓存。也就是说需要经过服务器验证的。</li>
</ul>
</li>
<li><h5 id="到期"><a href="#到期" class="headerlink" title="到期"></a>到期</h5><ul>
<li>max-age=<seconds><br>缓存有效期</li>
<li>s-maxage=<seconds><br>代替上面的 max-age，但是只有在代理服务器里面才会生效</li>
<li>max-stale=<seconds><br>max-stale：浏览器用不到，浏览器并不会主动去设置这个头，只有在发起端设置是有用的，服务端返回的内容中设置没有用。发起请求方，主动带的头，在 max-age 过期之后，如果我们返回的资源中有这个 max-stale 设置，还可以使用过期的缓存，而不需要去服务器请求新的内容。</li>
</ul>
</li>
<li><h5 id="重新验证"><a href="#重新验证" class="headerlink" title="重新验证"></a>重新验证</h5><ul>
<li>must-revalidate<br>设置了 max-age，如果缓存已经过期了，必须去原服务端发送这个请求，重新获取数据，来验证内容是否真的过期了，而不能直接使用本地缓存。</li>
<li>proxy-revalidate<br>用在指定缓存服务器，在过期的时候必须去原服务器重新请求一遍，而不能直接使用本地缓存。</li>
</ul>
</li>
<li><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul>
<li>no-store<br>本地和代理服务器不可以存储这个缓存，永远要去服务器拿新的 body 的内容。</li>
<li>no-transform<br>不允许代理服务器不要改动返回的内容。  </li>
</ul>
</li>
</ul>
<h3 id="浏览器中用到的"><a href="#浏览器中用到的" class="headerlink" title="浏览器中用到的:"></a>浏览器中用到的:</h3><ul>
<li><h5 id="可缓存性-1"><a href="#可缓存性-1" class="headerlink" title="可缓存性"></a>可缓存性</h5><ul>
<li>public</li>
<li>private</li>
<li>no-cahe</li>
</ul>
</li>
<li><h5 id="到期-1"><a href="#到期-1" class="headerlink" title="到期"></a>到期</h5><ul>
<li>max-age=<seconds></li>
<li>s-maxage=<seconds></li>
<li>max-stale=<seconds></li>
</ul>
</li>
<li><h5 id="重新验证-1"><a href="#重新验证-1" class="headerlink" title="重新验证"></a>重新验证</h5><ul>
<li><p>must-revalidate</p>
</li>
<li><p>设置请求文件缓存时间<br><code>&#39;Cache-Control&#39;: &#39;max-age=20&#39;</code></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.createServer(function (request, response) &#123;</span><br><span class="line">  console.log(&apos;request come&apos;, request.url)</span><br><span class="line"></span><br><span class="line">  if (request.url === &apos;/&apos;) &#123;</span><br><span class="line">    const html = fs.readFileSync(&apos;test.html&apos;, &apos;utf8&apos;)</span><br><span class="line">    response.writeHead(200, &#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;text/html&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    response.end(html)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (request.url === &apos;/script.js&apos;) &#123;</span><br><span class="line">    response.writeHead(200, &#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;text/javascript&apos;,</span><br><span class="line">      // 设置到期时间</span><br><span class="line">      &apos;Cache-Control&apos;: &apos;max-age=20&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    response.end(&apos;console.log(&quot;script loaded&quot;)&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(8888)</span><br></pre></td></tr></table></figure>

<p>问题 ： 这时如果改变了服务器返回的结果，刷新，发现返回的还是之前的结果，并不是最新的。这是因为服务器端更新了之后，客户端还是请求的缓存的资源，这样想要更新一个应用的时候，客户端根本触及不到了，一般 max-ag 可能会设置一年。<br>解决：在构建流程的时候，把打包完成的 JS 文件名根据内容的 hash 结果，加上一串 hash 码，这串 hash 码是因为根据打包完成的 js 以及其他静态资源的文件内容进行性的 hash 计算，所以如果这些静态文件内容没有变，hash 码就不变，反应到 web 页面上就是 url 没有变，那么就可以使用静态缓存；而如果你的内容有变，hash 码就会变化，嵌入在 html 的 url 路径就有变化，有了变化之后发起的请求就是一个新的静态资源请求而不是之前缓存的请求。这样就可以达到缓存的目的。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Java文件读写</title>
    <url>/2019/11/18/Java%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<h2 id="Java文件读写"><a href="#Java文件读写" class="headerlink" title="Java文件读写"></a>Java文件读写</h2><a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/13863123-3b31b9635a45a269.jpg" alt=""> <img src="http://upload-images.jianshu.io/upload_images/13863123-e669017cd996500b.jpg" alt=""></p>
<h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a><strong>IO 流</strong></h3><ol>
<li>IO 流：用于处理设备上的数据。</li>
</ol>
<p>设备：硬盘，内存，键盘录入。</p>
<ol start="2">
<li>IO 有具体的分类：</li>
</ol>
<p>（1）根据处理的数据类型不同：字节流和字符流。</p>
<p>（2）根据流向不同：输入流和输出流。</p>
<p>字符流的由来：</p>
<p>因为文件编码的不同，而有了对字符进行高效操作的字符流对象。</p>
<p>原理：其实就是基于字节流读取字节时，去查了指定的码表。</p>
<p>字节流和字符流的区别：</p>
<p>（1）字节流读取的时候，读到一个字节就返回一个字节。</p>
<p>字符流使用了字节流读到一个或多个字节（中文对应的字节数是两个，在 UTF-8 码表中是 3 个字节）时，先去查指定的编码表，将查到的字符返回。</p>
<p><strong>（2）字节流可以处理所有类型数据，如 MP3，图片，avi。而字符流只能处理字符数据。</strong></p>
<p><strong>结论：只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都要用字节流。</strong></p>
<p>IO 的体系，所具备的基本功能就有两个：读和写。</p>
<ol>
<li><p>字节流：InputStream(读)，OutputStream（写）。</p>
</li>
<li><p>字符流：Reader（读），Writer（写）。</p>
</li>
</ol>
<h3 id="一-字符流"><a href="#一-字符流" class="headerlink" title="一. 字符流:"></a><strong>一. 字符流:</strong></h3><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p>|–InputStreamReader  </p>
<p>　　 |–FileReader: 专门用于处理文件的字符读取流对象。  </p>
<h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p> |–OutputStreamWriter  </p>
<p>　　 |–FileWriter: 专门用于处理文件的字符写入流对象</p>
<h4 id="Reader-中的常见的方法："><a href="#Reader-中的常见的方法：" class="headerlink" title="Reader 中的常见的方法："></a>Reader 中的常见的方法：</h4><ol>
<li>int read()：  </li>
</ol>
<p>　　 读取一个字符。返回的是读到的那个字符。如果读到流的末尾，返回 - 1.  </p>
<p>*<em>2. int read(char[])：    *</em></p>
<p>**　　将读到的字符存入指定的数组中，返回的是读到的字符个数，也就是往数组里装的元素的个数。如果读到流的末尾，返回 - 1.  **</p>
<ol start="3">
<li>close():    </li>
</ol>
<p>　　读取字符其实用的是 window 系统的功能，就希望使用完毕后，进行资源的释放。</p>
<h4 id="Writer-中的常见的方法："><a href="#Writer-中的常见的方法：" class="headerlink" title="Writer 中的常见的方法："></a>Writer 中的常见的方法：</h4><p>1，write(ch): 将一个字符写入到流中。  </p>
<p>2，write(char[]): 将一个字符数组写入到流中。</p>
<p>3，write(String): 将一个字符串写入到流中。  </p>
<p>4，flush(): 刷新流，将流中的数据刷新到目的地中，流还存在。  </p>
<p>5，close(): 关闭资源：在关闭前会先调用 flush()，刷新流中的数据去目的地。然流关闭。</p>
<h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter:"></a>FileWriter:</h4><p>该类没有特有的方法。只有自己的构造函数。  </p>
<p>该类特点在于，  </p>
<p>1，用于处理文本文件。  </p>
<p>2，该类中有默认的编码表，  </p>
<p>3，该类中有临时缓冲。</p>
<p>构造函数：在写入流对象初始化时，必须要有一个存储数据的目的地。</p>
<p>  FileWriter(String filename):   该构造函数做了什么事情呢？  </p>
<p>1，调用系统资源。  </p>
<p>2，在指定位置，创建一个文件。  </p>
<p> 注意：如果该文件已存在，将会被覆盖。  </p>
<p>FileWriter(String filename,boolean append):  </p>
<p> 　　该构造函数：当传入的 boolean 类型值为 true 时，会在指定文件末尾处进行数据的续写。</p>
<h4 id="FileReader："><a href="#FileReader：" class="headerlink" title="FileReader："></a>FileReader：</h4><p>1，用于读取文本文件的流对象。  </p>
<p>2，用于关联文本文件。</p>
<p> 构造函数：在读取流对象初始化的时候，必须要指定一个被读取的文件。    </p>
<p>如果该文件不存在会发生 FileNotFoundException.  </p>
<h4 id="FileReader-String-filename"><a href="#FileReader-String-filename" class="headerlink" title="FileReader(String filename);"></a>FileReader(String filename);</h4><p>对于读取或者写入流对象的构造函数，以及读写方法，还有刷新关闭功能都会抛出 IOException 或其子类。</p>
<p>所以都要进行处理，或者 throws 抛出，或者 try、catch 处理。</p>
<h4 id="另一个小细节："><a href="#另一个小细节：" class="headerlink" title="*另一个小细节：  *"></a>*<em>另一个小细节：  *</em></h4><p><strong>当指定绝对路径时，定义目录分隔符有两种方式：</strong></p>
<p><strong>1，反斜线 但是一定要写两个。\  new FileWriter(“c:\demo.txt”);</strong></p>
<p><strong>2，斜线  /  写一个即可。 new FileWriter(“c:/demo.txt”);</strong></p>
<h4 id="字符流的缓冲区："><a href="#字符流的缓冲区：" class="headerlink" title="字符流的缓冲区："></a><strong>字符流的缓冲区：</strong></h4><p>缓冲区的出现提高了对流的操作效率。</p>
<p>原理：其实就是将数组进行封装。</p>
<p>对应的对象：</p>
<p>BufferedWriter：</p>
<p>　　特有方法：</p>
<p><strong>newLine（）：跨平台的换行符。</strong></p>
<p>BufferedReader：</p>
<p>　　特有方法：</p>
<p><strong>readLine（）：一次读一行，到行标记时，将行标记之前的字符数据作为字符串返回。当读到末尾时，返回 null。</strong></p>
<p>使用缓冲区对象时，要明确，缓冲的存在是为了增强流的功能而存在，所以在简历缓冲区对象时，要现有流对象存在。</p>
<p>其实缓冲内部就是在使用流对象的方法，只不过加入了数组对数据进行了临时存储，为了提高操作数据的效率。</p>
<p>代码上的体现:</p>
<p><strong>写入缓冲区对象：</strong></p>
<p>// 建立缓冲区对象必须把流对象作为参数传递给缓冲区的构造函数。</p>
<p>BufferedWriter bw=new BufferedWriter（new FileWriter（“abc.txt”））；</p>
<p>bw.write(“abce”);// 将数据写入到了缓冲区。</p>
<p>bw.flush();// 对缓冲区的数据进行刷新。将数据刷到目的地中。</p>
<p>bw.close();// 关闭缓冲区，其实关闭的是被包装在内部的流对象。</p>
<h3 id="二-字节流"><a href="#二-字节流" class="headerlink" title="二. 字节流:"></a><strong>二. 字节流:</strong></h3><p>抽象基类: InputStream，OutputStream。</p>
<p>字节流可以操作任何数据。</p>
<p>注意：字符流使用的数组是字符数组，char[] chs ；</p>
<p>　　　字节流使用的数组是字节数组，byte[] bt ；</p>
<p>FileOutputStream fos=new FileOutputStream(“a.txt”)；</p>
<p>fos.write(“abcde”); // 直接将数据写入到了目的地。</p>
<p>fos.close();// 只关闭资源。</p>
<p>FileInputSteam fls=new FileInputStream(“a.txt”);</p>
<p>//fis.available();// 获取关联的文件字节数。如果文件体积不大，可以这样操作。</p>
<p>byte[]buf=new byte[fis.available()];// 创建一个刚刚好的缓冲区。// 但是这有一个弊端，就是文件过大，大小超出 Jvm 的内容空间时，会内存溢出。</p>
<p>fis.read(buf);</p>
<p>System.out.println(new String(buf));</p>
<p>例子:</p>
<p>　　需求: copy 一个图片。</p>
<p>BufferedInputStream bufis=new BufferedInputStream(new FileInputStream(“1.jpg”));</p>
<p>BufferedOutputStream bufos=new BufferedOutputStream(new FileOutputStream(“2.jpg”));</p>
<p>int by=0;</p>
<p>while(by=bufis.read()!=-1){</p>
<p>　　bufos.write(by);</p>
<p>　　bufos.newLine();</p>
<p>}</p>
<p>bufis.close();</p>
<p>bufos.close();</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结:"></a><strong>小结:</strong></h3><p>目前学习的流对象:</p>
<p>字符流: FileReader  FileWriter  BuffereedReader  BufferedWriter</p>
<p>字节流: FileInputStream  FileOutputStream   BufferedInputStream  BufferedOutputStream</p>
<p>补充：</p>
<ol>
<li>字节流的 read（）方法读取的是一个字节。为什么返回的不是 byte 类型，而是 int 类型呢？</li>
</ol>
<p>因为 read 方法读到末尾时返回的是 - 1，而在所操作的数据中很容易出现连续多个 1 的情况，而连续读到 8 个 1，就是 - 1，导致读取会提前停止。所以将读到的一个字节提升为一个 int 类型的数值，但是只保留原字节，并在剩余二进制位补 0。</p>
<p>具体操作是：byte&amp;255 or byte&amp;0xff</p>
<ol start="2">
<li>对于 write 方法，可以一次写入一个字节，但接收的是一个 int 类型数值。只写入该 int 类型的数值的最低一个字节（8 位）。</li>
</ol>
<p>简单说：<strong>read 方法对读到的数据进行提升，write 对操作的数据进行转换。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>File</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>DataURL, Blob, File, Image 之间的关系与转换</title>
    <url>/2019/11/18/DataURL-Blob-File-Image-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="使用前景："><a href="#使用前景：" class="headerlink" title="使用前景："></a>使用前景：</h4><p><strong><em>移动端上传拍照图片太大，使用 canvas 压缩后 base64=&gt;blob 二进制表单文件 =&gt;ajax-POST 上传</em></strong> <a id="more"></a><img src="https://oscimg.oschina.net/oscnet/45bb5cc130ba93fa7d2365fb81304c75f9a.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// canvas转dataURL：canvas对象、转换格式、图像品质</span><br><span class="line">function canvasToDataURL(canvas, format, quality) &#123;</span><br><span class="line">    return canvas.toDataURL(format||&apos;image/jpeg&apos;, quality||1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// DataURL转canvas</span><br><span class="line">function dataURLToCanvas(dataurl, cb)&#123;</span><br><span class="line">    var canvas = document.createElement(&apos;CANVAS&apos;);</span><br><span class="line">    var ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.onload = function()&#123;</span><br><span class="line">        canvas.width = img.width;</span><br><span class="line">        canvas.height = img.height;</span><br><span class="line">        ctx.drawImage(img, 0, 0);</span><br><span class="line">        cb(canvas);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = dataurl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// image转canvas：图片地址</span><br><span class="line">function imageToCanvas(src, cb)&#123;</span><br><span class="line">    var canvas = document.createElement(&apos;CANVAS&apos;);</span><br><span class="line">    var ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.src = src;</span><br><span class="line">    img.onload = function ()&#123;</span><br><span class="line">        canvas.width = img.width;</span><br><span class="line">        canvas.height = img.height;</span><br><span class="line">        ctx.drawImage(img, 0, 0);</span><br><span class="line">        cb(canvas);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// canvas转image</span><br><span class="line">    function canvasToImage(canvas)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">        img.src = canvas.toDataURL(&apos;image/jpeg&apos;, 1.0);</span><br><span class="line">        return img;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// File/Blob对象转DataURL</span><br><span class="line">    function fileOrBlobToDataURL(obj, cb)&#123;</span><br><span class="line">        var a = new FileReader();</span><br><span class="line">        a.readAsDataURL(obj);</span><br><span class="line">        a.onload = function (e)&#123;</span><br><span class="line">            cb(e.target.result);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// DataURL转Blob对象</span><br><span class="line">    function dataURLToBlob(dataurl)&#123;</span><br><span class="line">        var arr = dataurl.split(&apos;,&apos;);</span><br><span class="line">        var mime = arr[0].match(/:(.*?);/)[1];</span><br><span class="line">        var bstr = atob(arr[1]);</span><br><span class="line">        var n = bstr.length;</span><br><span class="line">        var u8arr = new Uint8Array(n);</span><br><span class="line">        while(n--)&#123;</span><br><span class="line">            u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Blob([u8arr], &#123;type:mime&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Blob转image</span><br><span class="line">    function blobToImage(blob, cb)&#123;</span><br><span class="line">        fileOrBlobToDataURL(blob, function (dataurl)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">            img.src = dataurl;</span><br><span class="line">            cb(img);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// image转Blob</span><br><span class="line">    function imageToBlob(src, cb)&#123;</span><br><span class="line">        imageToCanvas(src, function (canvas)&#123;</span><br><span class="line">            cb(dataURLToBlob(canvasToDataURL(canvas)));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Blob转canvas</span><br><span class="line">    function BlobToCanvas(blob, cb)&#123;</span><br><span class="line">        fileOrBlobToDataURL(blob, function (dataurl)&#123;</span><br><span class="line">            dataURLToCanvas(dataurl, cb);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// canvas转Blob</span><br><span class="line">function canvasToBlob(canvas, cb)&#123;</span><br><span class="line">	cb(dataURLToBlob(canvasToDataURL(canvas)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// image转dataURL</span><br><span class="line">function imageToDataURL(src, cb)&#123;</span><br><span class="line">	imageToCanvas(src, function (canvas)&#123;</span><br><span class="line">		cb(canvasToDataURL(canvas));</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// dataURL转image，这个不需要转，直接给了src就能用</span><br><span class="line">function dataURLToImage(dataurl)&#123;</span><br><span class="line">	var img = new Image();</span><br><span class="line">	img.src = d;</span><br><span class="line">	return img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Blob</tag>
        <tag>File</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p>hello world!!</p>
]]></content>
  </entry>
</search>
