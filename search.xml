<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>接口and多态</title>
    <url>/2020/01/06/%E6%8E%A5%E5%8F%A3and%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>就在Java学习接口和多态时的一些笔记！</p>
<a id="more"></a>
<h4 id="什么是接口？"><a href="#什么是接口？" class="headerlink" title="什么是接口？"></a>什么是接口？</h4><ul>
<li><p>接口就是多个类的公共规范。</p>
</li>
<li><p>接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。</p>
</li>
</ul>
<hr>
<h5 id="如何定义一个接口的格式："><a href="#如何定义一个接口的格式：" class="headerlink" title="如何定义一个接口的格式："></a>如何定义一个接口的格式：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface 接口名称 &#123;</span><br><span class="line">    // 接口内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>备注：</strong>换成了关键字interface之后，编译生成的字节码文件仍然是：.java –&gt; .class。</p>
<hr>
<h4 id="如果是Java-7，那么接口中可以包含的内容有："><a href="#如果是Java-7，那么接口中可以包含的内容有：" class="headerlink" title="如果是Java 7，那么接口中可以包含的内容有："></a>如果是Java 7，那么接口中可以包含的内容有：</h4><ul>
<li>常量</li>
<li>抽象方法</li>
</ul>
<h4 id="如果是Java-8，还可以额外包含有："><a href="#如果是Java-8，还可以额外包含有：" class="headerlink" title="如果是Java 8，还可以额外包含有："></a>如果是Java 8，还可以额外包含有：</h4><ul>
<li>默认方法</li>
<li>静态方法</li>
</ul>
<h4 id="如果是Java-9，还可以额外包含有："><a href="#如果是Java-9，还可以额外包含有：" class="headerlink" title="如果是Java 9，还可以额外包含有："></a>如果是Java 9，还可以额外包含有：</h4><ul>
<li>私有方法</li>
</ul>
<hr>
<h4 id="接口使用步骤："><a href="#接口使用步骤：" class="headerlink" title="接口使用步骤："></a>接口使用步骤：</h4><ul>
<li><p>1、接口不能直接使用，必须有一个“实现类”来“实现”该接口。</p>
<ul>
<li><strong>[格式]：</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class 实现类名称 implements 接口名称 &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2、接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。</p>
<ul>
<li><strong>[实现]：</strong>去掉abstract关键字，加上方法体大括号。</li>
</ul>
</li>
</ul>
<ul>
<li>3、创建实现类的对象，进行使用。</li>
</ul>
<h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><p>如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。</p>
<hr>
<ul>
<li><p>接口的默认方法，可以通过接口实现类对象，直接调用。</p>
</li>
<li><p>接口的默认方法，也可以被接口实现类进行覆盖重写。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>[注意事项]：</strong>不能通过接口实现类的对象来调用接口当中的静态方法。</p>
</li>
<li><p><strong>[正确用法]：</strong>通过接口名称，直接调用其中的静态方法。</p>
</li>
<li><p><strong>[格式]：</strong>接口名称.静态方法名(参数);</p>
</li>
</ul>
<hr>
<h4 id="在任何版本的Java中，接口都能定义抽象方法。"><a href="#在任何版本的Java中，接口都能定义抽象方法。" class="headerlink" title="在任何版本的Java中，接口都能定义抽象方法。"></a>在任何版本的Java中，接口都能定义抽象方法。</h4><p><strong>[格式]：</strong><br>public abstract 返回值类型 方法名称(参数列表);</p>
<p><strong>[注意事项]：</strong></p>
<ul>
<li><p>接口当中的抽象方法，修饰符必须是<strong>[两个固定]</strong>的关键字：public abstract</p>
</li>
<li><p>这两个关键字修饰符，可以选择性地省略。<strong>(不推荐)</strong></p>
</li>
<li><p>方法的三要素，可以随意定义。</p>
</li>
</ul>
<hr>
<blockquote>
<p>接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。<br>从效果上看，这其实就是接口的【常量】。</p>
</blockquote>
<ul>
<li><p><strong>[格式]</strong>：<br>public static final 数据类型 常量名称 = 数据值;</p>
</li>
<li><p><strong>[备注]</strong>：<br>一旦使用final关键字进行修饰，说明不可改变。</p>
</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li><p>接口当中的常量，可以省略public static final，注意：不写也照样是这样。</p>
</li>
<li><p>接口当中的常量，必须进行赋值；不能不赋值。</p>
</li>
<li><p>接口中常量的名称，使用完全大写的字母，用下划线进行分隔。<strong>（推荐命名规则）</strong></p>
</li>
</ul>
<hr>
<h4 id="从Java-8开始，接口里允许定义默认方法。"><a href="#从Java-8开始，接口里允许定义默认方法。" class="headerlink" title="从Java 8开始，接口里允许定义默认方法。"></a>从Java 8开始，接口里允许定义默认方法。</h4><ul>
<li><strong>[格式]：</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public default 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>[备注]</strong>：接口当中的默认方法，可以解决接口升级的问题。</li>
</ul>
<hr>
<h5 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h5><p>我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。<br>但是这个共有方法不应该让实现类使用，应该是私有化的。</p>
<h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><p>从Java 9开始，接口当中允许定义私有方法。</p>
<ul>
<li><p>普通私有方法，解决多个默认方法之间重复代码问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>静态私有方法，解决多个静态方法之间重复代码问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>从Java 8开始，接口当中允许定义<strong>静态方法</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>[提示]：</strong>就是将abstract或者default换成static即可，带上方法体。</p>
<hr>
<p><strong>使用接口的时候，需要注意：</strong></p>
<ul>
<li><p>1.接口是没有静态代码块或者构造方法的。</p>
</li>
<li><p>2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB &#123;</span><br><span class="line">    // 覆盖重写所有抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。</p>
</li>
<li><p>4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。</p>
</li>
<li><p>5.如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</p>
</li>
<li><p>6.一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。</p>
</li>
</ul>
<hr>
<ul>
<li><p>1.类与类之间是单继承的。直接父类只有一个。</p>
</li>
<li><p>2.类与接口之间是多实现的。一个类可以实现多个接口。</p>
</li>
<li><p>3.接口与接口之间是多继承的。</p>
</li>
</ul>
<p><strong>[注意事项]：</strong></p>
<ul>
<li><p>1.多个父接口当中的抽象方法如果重复，没关系。</p>
</li>
<li><p>2.多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。</p>
</li>
</ul>
<hr>
<h4 id="代码当中体现多态性，其实就是一句话：父类引用指向子类对象。"><a href="#代码当中体现多态性，其实就是一句话：父类引用指向子类对象。" class="headerlink" title="代码当中体现多态性，其实就是一句话：父类引用指向子类对象。"></a>代码当中体现多态性，其实就是一句话：父类引用指向子类对象。</h4><p><strong>[格式：]</strong></p>
<ul>
<li><p>父类名称 对象名 = new 子类名称();</p>
</li>
<li><p>接口名称 对象名 = new 实现类名称();</p>
</li>
</ul>
<hr>
<h4 id="访问成员变量的两种方式："><a href="#访问成员变量的两种方式：" class="headerlink" title="访问成员变量的两种方式："></a>访问成员变量的两种方式：</h4><ul>
<li><p>1.直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。</p>
</li>
<li><p>2.间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。</p>
</li>
</ul>
<hr>
<p><strong>在多态的代码当中，成员方法的访问规则是：</strong></p>
<pre><code>看new的是谁，就优先用谁，没有则向上找。</code></pre><p><strong>口诀：</strong>编译看左边，运行看右边。</p>
<p><strong>对比一下：</strong></p>
<ul>
<li><p>成员变量：编译看左边，运行还看左边。</p>
</li>
<li><p>成员方法：编译看左边，运行看右边。</p>
</li>
</ul>
<hr>
<p>向上转型一定是安全的，没有问题的，正确的。</p>
<p>但是也有一个<strong>弊端：</strong><br>对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。</p>
<p><strong>解决方案：</strong>用对象的向下转型【还原】。</p>
<hr>
<h4 id="如何才能知道一个父类引用的对象，本来是什么子类？"><a href="#如何才能知道一个父类引用的对象，本来是什么子类？" class="headerlink" title="如何才能知道一个父类引用的对象，本来是什么子类？"></a>如何才能知道一个父类引用的对象，本来是什么子类？</h4><p><strong>格式：</strong><br>对象 instanceof 类名称</p>
<p>这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。</p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>interface</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>继承and抽象</title>
    <url>/2020/01/06/%E7%BB%A7%E6%89%BFand%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<p>就在Java学习继承和抽象时的一些笔记！</p>
<a id="more"></a>
<h4 id="在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式："><a href="#在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：" class="headerlink" title="在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式："></a>在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：</h4><ul>
<li><p>直接通过子类对象访问成员变量：<br>  等号左边是谁，就优先用谁，没有则向上找。</p>
</li>
<li><p>间接通过成员方法访问成员变量：<br>  该方法属于谁，就优先用谁，没有则向上找。</p>
</li>
</ul>
<hr>
<h4 id="区分this和super"><a href="#区分this和super" class="headerlink" title="区分this和super"></a>区分this和super</h4><ul>
<li><p>局部变量：         直接写成员变量名</p>
</li>
<li><p>本类的成员变量：    this.成员变量名</p>
</li>
<li><p>父类的成员变量：    super.成员变量名</p>
</li>
</ul>
<hr>
<h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><ul>
<li><p>在父子类的继承关系当中，创建子类对象，访问成员方法的规则：<br>  创建的对象是谁，就优先用谁，如果没有则向上找。</p>
</li>
<li><p>注意事项：<br>  无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。</p>
</li>
<li><p>重写（Override）<br>概念：在继承关系当中，方法的名称一样，参数列表也一样。</p>
</li>
<li><p>重写（Override）：方法的名称一样，参数列表【也一样】。覆盖、覆写。</p>
</li>
<li><p>重载（Overload）：方法的名称一样，参数列表【不一样】。</p>
</li>
<li><p>方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。</p>
</li>
</ul>
<hr>
<h4 id="方法覆盖重写的注意事项："><a href="#方法覆盖重写的注意事项：" class="headerlink" title="方法覆盖重写的注意事项："></a>方法覆盖重写的注意事项：</h4><ul>
<li>必须保证父子类之间方法的名称相同，参数列表也相同。<ul>
<li>@Override：写在方法前面，用来检测是不是有效的正确覆盖重写。<br>这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</li>
</ul>
</li>
</ul>
<ul>
<li>子类方法的返回值必须【小于等于】父类方法的返回值范围。<ul>
<li>小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。</li>
</ul>
</li>
</ul>
<ul>
<li>子类方法的权限必须【大于等于】父类方法的权限修饰符。<ul>
<li>小扩展提示：public &gt; protected &gt; (default) &gt; private</li>
</ul>
</li>
</ul>
<ul>
<li>备注：(default)不是关键字default，而是什么都不写，留空。</li>
</ul>
<hr>
<h4 id="继承关系中，父子类构造方法的访问特点："><a href="#继承关系中，父子类构造方法的访问特点：" class="headerlink" title="继承关系中，父子类构造方法的访问特点："></a>继承关系中，父子类构造方法的访问特点：</h4><ul>
<li><p>子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。</p>
</li>
<li><p>子类构造可以通过super关键字来调用父类重载构造。</p>
</li>
<li><p>super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</p>
</li>
<li><p><strong>总结</strong>：<br>子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。</p>
</li>
</ul>
<hr>
<h4 id="super关键字的用法有三种："><a href="#super关键字的用法有三种：" class="headerlink" title="super关键字的用法有三种："></a>super关键字的用法有三种：</h4><ul>
<li><p>在子类的成员方法中，访问父类的成员变量。</p>
</li>
<li><p>在子类的成员方法中，访问父类的成员方法。</p>
</li>
<li><p>在子类的构造方法中，访问父类的构造方法。</p>
</li>
</ul>
<hr>
<h4 id="super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种："><a href="#super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：" class="headerlink" title="super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种："></a>super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：</h4><ul>
<li><p>在本类的成员方法中，访问本类的成员变量。</p>
</li>
<li><p>在本类的成员方法中，访问本类的另一个成员方法。</p>
</li>
<li><p>在本类的构造方法中，访问本类的另一个构造方法。</p>
</li>
<li><p><strong>在第三种用法当中要注意：</strong></p>
<ul>
<li><p>A. this(…)调用也必须是构造方法的第一个语句，唯一一个。</p>
</li>
<li><p>B. super和this两种构造调用，不能同时使用。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="抽象方法和抽象类"><a href="#抽象方法和抽象类" class="headerlink" title="抽象方法和抽象类"></a>抽象方法和抽象类</h4><ul>
<li><p>抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。</p>
</li>
<li><p>抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。</p>
</li>
</ul>
<h6 id="如何使用抽象类和抽象方法："><a href="#如何使用抽象类和抽象方法：" class="headerlink" title="如何使用抽象类和抽象方法："></a>如何使用抽象类和抽象方法：</h6><ul>
<li><p>不能直接创建new抽象类对象。</p>
</li>
<li><p>必须用一个子类来继承抽象父类。</p>
</li>
<li><p>子类必须覆盖重写抽象父类当中所有的抽象方法。</p>
<ul>
<li>覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</li>
</ul>
</li>
</ul>
<ul>
<li>创建子类对象进行使用。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>extends</tag>
        <tag>abstract</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存分配</title>
    <url>/2019/12/15/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>Java 程序运行时，需要在内存中分配空间。为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。</p>
<a id="more"></a>
<p>一、栈：储存局部变量</p>
<ul>
<li>局部变量：在方法的定义中或者在方法声明上的变量称为局部变量。</li>
<li>特点：栈内存的数据用完就释放。</li>
</ul>
<p>二、堆：储存 new 出来的东西</p>
<ul>
<li>特点：<ul>
<li>每一个 new 出来的东西都有地址值；</li>
<li>每个变量都有默认值 （byte, short, int, long 的默认值为 0；float, double 的默认值为 0.0；char 的默认值为 “\u0000”；boolean 的默认值为 false；引用类型为 null）；</li>
<li>使用完毕就变成垃圾，但是并没有立即回收。会有垃圾回收器空闲的时候回收。</li>
</ul>
</li>
</ul>
<p><img src="/2019/12/15/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1.png" alt></p>
<p><img src="/2019/12/15/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/2.png" alt></p>
<p>三、方法区：</p>
<p>一个对象的运行过程：</p>
<ol>
<li><strong>程序从 main 方法中进入；运行到 Phone p 时，在栈中开辟了一个空间；</strong></li>
<li><strong>new Phone() 时，在队中开了一个内存空间，此时会有一个内存值为 0x0001；此时会找到对应的 Phone 的 class 文件，发现有三个变量和三个方法，于是将三个成员变量放在了堆中，但是此时的值为默认值（具体默认值见上）。注意，在方法区里也有一个地址值，假设为 0x001，可以认为在堆中也有一个位置，在堆中的位置，可以找到方法区中相对应的方法；</strong></li>
<li><strong>继续运行，p.brand = “三星”；将三星赋值给 p.brand，通过栈中的 p 找到了堆中的 brand，此时的 null 值变为 “三星”。剩下的类似；</strong></li>
<li><strong>当运行到 p.call(“乔布斯”) 时，通过栈中的 p 找到堆中存在的方法区的内存地址，从而指引到方法区中的 Phone.class 中的方法。从而将 call 方法加载到栈内存中，注意：当执行完毕后，call 方法就从栈内存中消失！剩余的如上。</strong></li>
<li><strong>最后，main 方法消失！</strong></li>
</ol>
<p><img src="/2019/12/15/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/3.png" alt></p>
<p><strong>两个对象的运行过程：</strong></p>
<ol>
<li><p><strong>程序从 main() 方法进入，运行到 Phone p 时，栈内存中开内存空间；</strong></p>
</li>
<li><p><strong>new Phone() 时，在队中开了一个内存空间，内存值为 0x0001；此时会找到对应的 Phone 类，发现有三个变量，于是将三个成员变量放在了堆中，但是此时的值为默认值。又发现该类还存在方法，于是将该方法的内存值留在了堆中，在方法区里也有一个地址值，假设为 0x001，这个值与堆中的值相对应；</strong></p>
</li>
<li><p><strong>程序继续运行，到 p.brand 时，进行了负值，同上；</strong></p>
</li>
<li><p><strong>当程序运行到 Phone p2 时；到 new Phone() 时，在堆内存中开辟了内存空间 0x0002，赋值给 Phone p2；</strong></p>
</li>
<li><p><strong>剩下跟一个对象的内存相同。</strong></p>
<p><img src="/2019/12/15/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/4.png" alt></p>
</li>
</ol>
<p><strong>三个对象的运行过程：</strong></p>
<ol>
<li><strong>基本流程跟前两个无差别；</strong></li>
<li><strong>但是当运行到 Phone p3 时，在栈内存中分配了一个空间，然后将 p1 的内存赋值给了 p3，即此时 Phone p3 的内存是指向 0x0001 的；</strong></li>
<li><strong>继续给变量赋值，会将原来已经赋值的变量给替换掉。</strong></li>
</ol>
<p><img src="/2019/12/15/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/5.png" alt></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>This的值到底是什么？</title>
    <url>/2019/11/19/This%E7%9A%84%E5%80%BC%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>你可能遇到过这样的 JS 面试题：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var obj = &#123;</span><br><span class="line">&gt;</span><br><span class="line">&gt;   foo: function()&#123;</span><br><span class="line">&gt;</span><br><span class="line">&gt;     console.log(this)</span><br><span class="line">&gt;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; var bar = obj.foo</span><br><span class="line">&gt;</span><br><span class="line">&gt; obj.foo() // 打印出的 this 是 obj</span><br><span class="line">&gt;</span><br><span class="line">&gt; bar() // 打印出的 this 是 window</span><br></pre></td></tr></table></figure>
<p>请解释最后两行函数的值为什么不一样。</p>
<p>——-</p>
<p>初学者关于 this 的理解一直很模糊。今天这篇文章就要一次讲清楚了。</p>
<p>而且这个解释，你在别的地方看不到。看懂这篇文章，所有关于 this 的面试题，都是小菜。</p>
<p><strong>函数调用</strong></p>
<p>首先需要从函数的调用开始讲起。</p>
<p>JS（ES5）里面有三种函数调用形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; func(p1, p2)</span><br><span class="line">&gt;</span><br><span class="line">&gt; obj.child.method(p1, p2)</span><br><span class="line">&gt;</span><br><span class="line">&gt; func.call(context, p1, p2) // 先不讲 apply</span><br></pre></td></tr></table></figure>
<p>一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。</p>
<p>从看到这篇文章起，你一定要记住，第三种调用形式，才是正常调用形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; func.call(context, p1, p2)</span><br></pre></td></tr></table></figure>
<p>其他两种都是语法糖，可以等价地变为 call 形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; func(p1, p2) 等价于</span><br><span class="line">&gt;</span><br><span class="line">&gt; func.call(undefined, p1, p2)</span><br><span class="line">&gt;</span><br><span class="line">&gt; obj.child.method(p1, p2) 等价于</span><br><span class="line">&gt;</span><br><span class="line">&gt; obj.child.method.call(obj.child, p1, p2)</span><br></pre></td></tr></table></figure>
<p>请记下来。（我们称此代码为「转换代码」，方便下文引用）</p>
<p>至此我们的函数调用只有一种形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; func.call(context, p1, p2)</span><br></pre></td></tr></table></figure>
<p>这样，this 就好解释了</p>
<p>this，就是上面代码中的 context。就这么简单。</p>
<p>this 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。</p>
<p>先看 func(p1, p2) 中的 this 如何确定：</p>
<p>当你写下面代码时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; function func()&#123;</span><br><span class="line">&gt;</span><br><span class="line">&gt;   console.log(this)</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; func()</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; function func()&#123;</span><br><span class="line">&gt;</span><br><span class="line">&gt;   console.log(this)</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; func.call(undefined) // 可以简写为 func.call()</span><br></pre></td></tr></table></figure>
<p>按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则：</p>
<p>如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</p>
<p>因此上面的打印结果是 window。</p>
<p>如果你希望这里的 this 不是 window，很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; func.call(obj) // 那么里面的 this 就是 obj 对象了</span><br></pre></td></tr></table></figure>
<p>再看 obj.child.method(p1, p2) 的 this 如何确定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var obj = &#123;</span><br><span class="line">&gt;</span><br><span class="line">&gt;   foo: function()&#123;</span><br><span class="line">&gt;</span><br><span class="line">&gt;     console.log(this)</span><br><span class="line">&gt;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; obj.foo()</span><br></pre></td></tr></table></figure>
<p>按照「转换代码」，我们将 obj.foo() 转换为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; obj.foo.call(obj)</span><br></pre></td></tr></table></figure>
<p>好了，this 就是 obj。搞定。</p>
<p>回到题目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var obj = &#123;</span><br><span class="line">&gt;</span><br><span class="line">&gt;   foo: function()&#123;</span><br><span class="line">&gt;</span><br><span class="line">&gt;     console.log(this)</span><br><span class="line">&gt;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; var bar = obj.foo</span><br><span class="line">&gt;</span><br><span class="line">&gt; obj.foo() // 转换为 obj.foo.call(obj)，this 就是 obj</span><br><span class="line">&gt;</span><br><span class="line">&gt; bar()</span><br><span class="line">&gt;</span><br><span class="line">&gt; // 转换为 bar.call()</span><br><span class="line">&gt;</span><br><span class="line">&gt; // 由于没有传 context</span><br><span class="line">&gt;</span><br><span class="line">&gt; // 所以 this 就是 undefined</span><br><span class="line">&gt;</span><br><span class="line">&gt; // 最后浏览器给你一个默认的 this —— window 对象</span><br></pre></td></tr></table></figure>
<p><strong>[ ] 语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; function fn ()&#123; console.log(this) &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; var arr = [fn, fn2]</span><br><span class="line">&gt;</span><br><span class="line">&gt; arr[0]() // 这里面的 this 又是什么呢？</span><br></pre></td></tr></table></figure>
<p>我们可以把 arr<a href>0</a> 想象为 arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; arr[0]()</span><br><span class="line">&gt;</span><br><span class="line">&gt; 假想为    arr.0()</span><br><span class="line">&gt;</span><br><span class="line">&gt; 然后转换为 arr.0.call(arr)</span><br><span class="line">&gt;</span><br><span class="line">&gt; 那么里面的 this 就是 arr 了 :)</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li><p>this 就是你 call 一个函数时，传入的 context。</p>
</li>
<li><p>如果你的函数调用形式不是 call 形式，请按照「转换代码」将其转换为 call 形式。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 的this</title>
    <url>/2019/11/19/JavaScript-%E7%9A%84this/</url>
    <content><![CDATA[<h2 id="1-this之谜"><a href="#1-this之谜" class="headerlink" title="1. this之谜"></a>1. <code>this</code>之谜</h2><p>许多时候，<code>this</code>关键词对我以及许多刚起步的 JavaScript 程序员来说，都是一个谜。它是一种很强大的特性，但是理解它需要花不少功夫。</p>
<a id="more"></a>
<p>对有 Java, PHP 或者其他常见的编程语言背景的人来说，<a href="https://en.wikipedia.org/wiki/This_(computer_programming)" target="_blank" rel="noopener"><code>this</code></a>仅仅被看成是类方法中当前对象的一个实例：不会多也不会少。多数时候，它不能在方法外被使用。正是这样一种简单的使用方法，避免了混淆。</p>
<p>在 JavaScript 中，<code>this</code>是当前执行函数的上下文。因为 JavaScript 有 4 种不同的函数调用方式：</p>
<ul>
<li>函数调用: <code>alert(&#39;Hello World!&#39;)</code></li>
<li>方法调用: <code>console.log(&#39;Hello World!&#39;)</code></li>
<li>构造函数调用: <code>new RegExp(&#39;\\d&#39;)</code></li>
<li>隐式调用: <code>alert.call(undefined, &#39;Hello World!&#39;)</code></li>
</ul>
<p>并且每种方法都定义了自己的上下文，<code>this</code>会表现得跟程序员预期的不太一样。同时，<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">strict 模式</a>也会影响函数执行时的上下文。</p>
<p>理解<code>this</code>的关键点就是要对函数调用以及它如何影响上下文有个清晰的观点。这篇文章将会着重于对函数调用的解释、函数调用如何影响<code>this</code>以及展示确定上下文时常见的陷阱。</p>
<p>在开始之前，让我们来熟悉一些术语：</p>
<ul>
<li><strong>函数调用</strong> 指执行构成一个函数的代码（简单说就是 call 一个函数）例如 <code>parseInt(&#39;15&#39;)</code>是<code>parseInt</code>函数<strong>调用</strong>.</li>
<li><strong>函数调用</strong>的<strong>上下文</strong>指<code>this</code>在函数体中的值。</li>
<li>函数的<strong>作用域</strong>指的是在函数体内可以使用的变量、对象以及函数的集合。</li>
</ul>
<h2 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2. 函数调用"></a>2. 函数调用</h2><p>当一个表达式为函数接着一个<code>(</code>，一些用逗号分隔的参数以及一个<code>）</code>时，<strong>函数调用</strong>被执行。例如<code>parseInt(&#39;18&#39;)</code>。这个表达式不能是<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors" target="_blank" rel="noopener">属性访问</a>，如<code>myObject.myFunction</code>，因为这会变成一个方法调用。举个例子，<code>[1,5].join(&#39;,&#39;)</code><strong>不是</strong>一个函数调用，而是一个方法调用。</p>
<p>一个简单的函数调用例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function hello(name) &#123;</span><br><span class="line">    return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class="line">&#125;</span><br><span class="line">// Function invocation</span><br><span class="line">var message = hello(&apos;World&apos;);</span><br><span class="line">console.log(message); // =&gt; &apos;Hello World!&apos;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>hello(&#39;World&#39;)</code>是函数调用: <code>hello</code>表达式等价于一个函数，跟在它后面的是一对括号以及<code>&#39;World&#39;</code>参数。</p>
<p>更加高级的例子是 <a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression" target="_blank" rel="noopener">IIFE</a> (立即调用的函数表达式):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;var message = (function(name) &#123;</span><br><span class="line">   return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class="line">&#125;)(&apos;World&apos;);</span><br><span class="line">console.log(message) // =&gt; &apos;Hello World!&apos;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>IIFE 也是一个函数调用: 第一对括号<code>(function(name) {...})</code> 是一个等价于函数的表达式, 紧接着一对括号以及<code>&#39;World&#39;</code>参数: <code>(&#39;World&#39;)</code>。</p>
<h3 id="2-1-在函数调用中的this"><a href="#2-1-在函数调用中的this" class="headerlink" title="2.1. 在函数调用中的this"></a>2.1. 在函数调用中的<code>this</code></h3><blockquote>
<p><code>this</code> 在函数调用中是一个<strong>全局对象</strong></p>
</blockquote>
<p>全局对象是由执行的环境决定的。在浏览器里它是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window" target="_blank" rel="noopener"><code>window</code></a>对象。</p>
<p>在函数调用里，函数执行的上下文是全局对象。让我们一起看看下面函数里的上下文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function sum(a, b) &#123;</span><br><span class="line">   console.log(this === window); // =&gt; true</span><br><span class="line">   this.myNumber = 20; // add &apos;myNumber&apos; property to global object</span><br><span class="line">   return a + b;</span><br><span class="line">&#125;</span><br><span class="line">// sum() is invoked as a function</span><br><span class="line">// this in sum() is a global object (window)</span><br><span class="line">sum(15, 16);     // =&gt; 31</span><br><span class="line">window.myNumber; // =&gt; 20&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>在<code>sum(15, 16)</code>被调用的时候，JavaScript 自动设置<code>this</code>指向全局对象，也就是浏览器里的<code>window</code>。</p>
<p>当<code>this</code>在所有函数作用域以外 (最上层的作用域：全局执行的上下文) 调用时，它也指向全局对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs coffeescript&quot;&gt;console.log(this === window); // =&gt; true</span><br><span class="line">this.myString = &apos;Hello World!&apos;;</span><br><span class="line">console.log(window.myString); // =&gt; &apos;Hello World!&apos;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs xml&quot;&gt;&lt;!-- In an html file --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt; console.log(this === window); // =&gt; true &lt;/script&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-函数调用中的this-strict-模式"><a href="#2-2-函数调用中的this-strict-模式" class="headerlink" title="2.2. 函数调用中的this, strict 模式"></a>2.2. 函数调用中的<code>this</code>, strict 模式</h3><blockquote>
<p>strict 模式下，函数调用中的<code>this</code>是<strong><code>undefined</code></strong></p>
</blockquote>
<p>strict 模式在 <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-10.1.1" target="_blank" rel="noopener">ECMAScript 5.1</a> 中被引入，它是一个受限制的 JavaScript 变种，提供了更好的安全性以及错误检查。为了使用它，把<code>&#39;use strict&#39;</code>放在函数体的开始。这个模式会影响执行的上下文，把<code>this</code>变成<code>undefined</code>。函数执行的上下文跟上面的例子 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#21thisinfunctioninvocation" target="_blank" rel="noopener">2.1</a> 相反，不再是全局对象</p>
<p>在 strict 模式下执行函数的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function multiply(a, b) &#123;</span><br><span class="line">    &apos;use strict&apos;; // enable the strict mode</span><br><span class="line">    console.log(this === undefined); // =&gt; true</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br><span class="line">// multiply() function invocation with strict mode enabled</span><br><span class="line">// this in multiply() is undefined</span><br><span class="line">multiply(2, 5); // =&gt; 10&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>当<code>multiply(2, 5)</code>作为函数被调用时，<code>this</code>是<code>undefined</code>。</p>
<p>strict 模式不仅在当前作用域起作用，也会对内部的作用域起作用 (对所有在内部定义的函数有效)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function execute() &#123;</span><br><span class="line">    &apos;use strict&apos;; // activate the strict mode</span><br><span class="line">    function concat(str1, str2) &#123;</span><br><span class="line">        // the strict mode is enabled too</span><br><span class="line">        console.log(this === undefined); // =&gt; true</span><br><span class="line">        return str1 + str2;</span><br><span class="line">    &#125;</span><br><span class="line">    // concat() is invoked as a function in strict mode</span><br><span class="line">    // this in concat() is undefined</span><br><span class="line">    concat(&apos;Hello&apos;, &apos; World!&apos;); // =&gt; &quot;Hello World!&quot;</span><br><span class="line">&#125;</span><br><span class="line">execute();&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>&#39;use strict&#39;</code> 插入在<code>execute</code>函数体的一开始, 使它在<code>execute</code>函数的作用域内起作用。 因为<code>concat</code>定义在<code>execute</code>的作用域内, 它也会继承 strict 模式， 这导致调用<code>concat(&#39;Hello&#39;, &#39; World!&#39;)</code>时， <code>this</code>是<code>undefined</code>。</p>
<p>单个的 JavaScript 文件可能既包含 strict 模式又包含非 strict 模式。所以，在单个的脚本内，同样的调用方法可能有不同的上下文行为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function nonStrictSum(a, b) &#123;</span><br><span class="line">    // non-strict mode</span><br><span class="line">    console.log(this === window); // =&gt; true</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">function strictSum(a, b) &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    // strict mode is enabled</span><br><span class="line">    console.log(this === undefined); // =&gt; true</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">// nonStrictSum() is invoked as a function in non-strict mode</span><br><span class="line">// this in nonStrictSum() is the window object</span><br><span class="line">nonStrictSum(5, 6); // =&gt; 11</span><br><span class="line">// strictSum() is invoked as a function in strict mode</span><br><span class="line">// this in strictSum() is undefined</span><br><span class="line">strictSum(8, 12); // =&gt; 20&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-陷阱-内部函数中的this"><a href="#2-3-陷阱-内部函数中的this" class="headerlink" title="2.3. 陷阱: 内部函数中的this"></a>2.3. 陷阱: 内部函数中的<code>this</code></h3><p>一个函数调用中的常见错误就是以为<code>this</code>在内部函数中跟在外部函数中一样。 正确来说，内部函数的上下文依赖于调用方法，而不是外部函数的上下文。 为了能使<code>this</code>跟预期的一样，用隐式调用来修改内部函数的上下文 (用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener"><code>.call()</code></a>或者<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener"><code>.apply()</code></a>, 如 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#5indirectinvocation" target="_blank" rel="noopener">5.</a> 所示) 或者创建一个绑定函数 (用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener"><code>.bind()</code></a>, 如 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#6boundfunction" target="_blank" rel="noopener">6.</a> 所示）。</p>
<p>下面的例子计算了 2 个数字的和：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;var numbers = &#123;</span><br><span class="line">   numberA: 5,</span><br><span class="line">   numberB: 10,</span><br><span class="line">   sum: function() &#123;</span><br><span class="line">     console.log(this === numbers); // =&gt; true</span><br><span class="line">     function calculate() &#123;</span><br><span class="line">       // this is window or undefined in strict mode</span><br><span class="line">       console.log(this === numbers); // =&gt; false</span><br><span class="line">       return this.numberA + this.numberB;</span><br><span class="line">     &#125;</span><br><span class="line">     return calculate();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">numbers.sum(); // =&gt; NaN or throws TypeError in strict mode&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>numbers.sum()</code>是一个对象上的方法调用 (见 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/3methodonanobjectinvocation" target="_blank" rel="noopener">3.</a>)，所以<code>sum</code>中的上下文是<code>numbers</code>对象。<code>calculate</code>函数定义在<code>sum</code>内部，所以你会指望<code>calculate()</code>中的<code>this</code>也是<code>numbers</code>对象。然而，<code>calculate()</code>是一个函数调用（而<strong>不是</strong>方法调用），它的<code>this</code>是全局对象<code>window</code>(例子 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#21thisinfunctioninvocation" target="_blank" rel="noopener">2.1.</a>) 或者 strict 模式下的<code>undefined</code>(例子 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#22thisinfunctioninvocationstrictmode" target="_blank" rel="noopener">2.2.</a>)。即使外部函数<code>sum</code>的上下文是<code>numbers</code>对象，它在这里也没有影响。<code>numbers.sum()</code>的调用结果是<code>NaN</code>或者 strict 模式下的<code>TypeError: Cannot read property &#39;numberA&#39; of undefined</code>错误。因为<code>calculate</code>没有被正确调用，结果绝不是预期的<code>5 + 10 = 15</code>。</p>
<p>为了解决这个问题，<code>calculate</code>应该跟<code>sum</code>有一样的上下文，以便于使用<code>numberA</code>和<code>numberB</code>。解决方法之一是使用<code>.call()</code>方法 (见章节 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#5indirectinvocation" target="_blank" rel="noopener">5.</a>):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;var numbers = &#123;</span><br><span class="line">   numberA: 5,</span><br><span class="line">   numberB: 10,</span><br><span class="line">   sum: function() &#123;</span><br><span class="line">     console.log(this === numbers); // =&gt; true</span><br><span class="line">     function calculate() &#123;</span><br><span class="line">       console.log(this === numbers); // =&gt; true</span><br><span class="line">       return this.numberA + this.numberB;</span><br><span class="line">     &#125;</span><br><span class="line">     // use .call() method to modify the context</span><br><span class="line">     return calculate.call(this);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">numbers.sum(); // =&gt; 15&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>calculate.call(this)</code>像往常一样执行<code>calculate</code>，但是上下文由第一个参数指定。现在<code>this.numberA + this.numberB</code>相当于<code>numbers.numberA + numbers.numberB</code>，函数会返回预期的结果<code>5 + 10 = 15</code>。</p>
<h2 id="3-方法调用"><a href="#3-方法调用" class="headerlink" title="3. 方法调用"></a>3. 方法调用</h2><p>一个<strong>方法</strong>是作为一个对象的属性存储的函数。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;var myObject = &#123;</span><br><span class="line">    // helloFunction is a method</span><br><span class="line">    helloFunction: function() &#123;</span><br><span class="line">        return &apos;Hello World!&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var message = myObject.helloFunction();&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>helloFunction</code>是<code>myObject</code>的一个方法。为了使用这个方法, 使用属性访问：<code>myObject.helloFunction</code>。</p>
<p>当一个表达式以属性访问的形式执行时，执行的是<strong>方法调用</strong>，它相当于以个函数接着<code>(</code>，一组用逗号分隔的参数以及<code>)</code>。 利用前面的例子，<code>myObject.helloFunction()</code>是对象<code>myObject</code>上的一个<code>helloFunction</code>的方法调用。<code>[1, 2].join(&#39;,&#39;)</code> 或<code>/\s/.test(&#39;beautiful world&#39;)</code>也被认为是方法调用。</p>
<p>区分<strong>函数调用</strong> (见 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#2functioninvocation" target="_blank" rel="noopener">2.</a>) 跟<strong>方法调用</strong>是很重要的，因为他们完全不同。他们最主要的区别在于方法调用要求函数以属性访问的形式调用 (如<code>&lt;expression&gt;.functionProperty()</code>或者<code>&lt;expression&gt;[&#39;functionProperty&#39;]()</code>)，而函数调用并没有这样的要求 (如<code>&lt;expression&gt;()</code>)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;[&apos;Hello&apos;, &apos;World&apos;].join(&apos;, &apos;); // method invocation</span><br><span class="line">(&#123; ten: function() &#123; return 10; &#125; &#125;).ten(); // method invocation</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.myFunction = function() &#123;</span><br><span class="line">  return new Date().toString();</span><br><span class="line">&#125;;</span><br><span class="line">obj.myFunction(); // method invocation</span><br><span class="line"></span><br><span class="line">var otherFunction = obj.myFunction;</span><br><span class="line">otherFunction();     // function invocation</span><br><span class="line">parseFloat(&apos;16.60&apos;); // function invocation</span><br><span class="line">isNaN(0);            // function invocation&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-方法调用中的this"><a href="#3-1-方法调用中的this" class="headerlink" title="3.1. 方法调用中的this"></a>3.1. 方法调用中的<code>this</code></h3><blockquote>
<p>在方法调用中，<code>this</code>是<strong>拥有这个方法的对象</strong></p>
</blockquote>
<p>当调用一个对象上的方法时，<code>this</code>变成这个对象自身。 让我们一起来创建一个对象，它带有一个可以增大数字的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;var calc = &#123;</span><br><span class="line">  num: 0,</span><br><span class="line">  increment: function() &#123;</span><br><span class="line">    console.log(this === calc); // =&gt; true</span><br><span class="line">    this.num += 1;</span><br><span class="line">    return this.num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// method invocation. this is calc</span><br><span class="line">calc.increment(); // =&gt; 1</span><br><span class="line">calc.increment(); // =&gt; 2&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>调用<code>calc.increment()</code>会把<code>increment</code>函数的上下文变成<code>calc</code>对象。所以，用<code>this.num</code>来增加 num 这个属性跟预期一样工作。</p>
<p>javaScript 对象会从它的<code>prototype</code>继承方法。当这个继承的方法在新的对象上被调用时，上下文仍然是该对象本身：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;var myDog = Object.create(&#123;</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">     console.log(this === myDog); // =&gt; true</span><br><span class="line">     return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">myDog.name = &apos;Milo&apos;;</span><br><span class="line">// method invocation. this is myDog</span><br><span class="line">myDog.sayName(); // =&gt; &apos;Milo&apos;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener"><code>Object.create()</code></a>创建了一个新的对象<code>myDog</code>，并且设置了它的 prototype。<code>myDog</code>继承了<code>sayName</code>方法。当执行<code>myDog.sayName()</code>时，<code>myDog</code>是调用的上下文。</p>
<p>在 ECMAScript 6 的 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener"><code>class</code></a>语法中，方法调用的上下文也是这个实例本身：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;class Planet &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    console.log(this === earth); // =&gt; true</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var earth = new Planet(&apos;Earth&apos;);</span><br><span class="line">// method invocation. the context is earth</span><br><span class="line">earth.getName(); // =&gt; &apos;Earth&apos;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-陷阱-从-object-中分离方法"><a href="#3-2-陷阱-从-object-中分离方法" class="headerlink" title="3.2. 陷阱: 从 object 中分离方法"></a>3.2. 陷阱: 从 object 中分离方法</h3><p>一个对象中的方法可以赋值给另一个变量。当用这个变量调用方法时，你可能以为<code>this</code>指向定义这个方法的对象。</p>
<p>正确来说如果这个方法在没有对象的时候被调用，它会变成函数调用：<code>this</code>变成全局对象<code>window</code>或者 strict 模式下的<code>undefined</code>(见 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#21thisinfunctioninvocation" target="_blank" rel="noopener">2.1</a> 和 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#22thisinfunctioninvocationstrictmode" target="_blank" rel="noopener">2.2</a>)。 用绑定函数 (用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener"><code>.bind()</code></a>, 见 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#6boundfunction" target="_blank" rel="noopener">6.</a>) 可以修正上下文，使它变成拥有这个方法的对象。</p>
<p>下面的例子创建了<code>Animal</code>构造函数并创造了它的一个实例 - <code>myCat</code>。 <code>setTimout()</code>会在 1 秒钟之后输出<code>myCat</code>对象的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function Animal(type, legs) &#123;</span><br><span class="line">    this.type = type;</span><br><span class="line">    this.legs = legs;</span><br><span class="line">    this.logInfo = function() &#123;</span><br><span class="line">        console.log(this === myCat); // =&gt; false</span><br><span class="line">        console.log(&apos;The &apos; + this.type + &apos; has &apos; + this.legs + &apos; legs&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var myCat = new Animal(&apos;Cat&apos;, 4);</span><br><span class="line">// logs &quot;The undefined has undefined legs&quot;</span><br><span class="line">// or throws a TypeError in strict mode</span><br><span class="line">setTimeout(myCat.logInfo, 1000);&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>你可能会以为<code>setTimout</code>会调用<code>myCat.logInfo()</code>，输出关于<code>myCat</code>对象的信息。实际上，这个方法在作为参数传递给<code>setTimout(myCat.logInfo)</code>时已经从原对象上分离了，1 秒钟之后发生的是一个函数调用。当<code>logInfo</code>作为函数被调用时，<code>this</code>是全局对象，或者 strict 模式下的<code>undefined</code>（反正<strong>不是</strong><code>myCat</code>对象），所以不会正确地输出信息。</p>
<p>函数可以通过<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener"><code>.bind()</code></a>方法跟一个对象绑定 (见 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#6boundfunction" target="_blank" rel="noopener">6.</a>)。如果这个分离的方法与<code>myCat</code>绑定，那么上下文的问题就解决了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function Animal(type, legs) &#123;</span><br><span class="line">    this.type = type;</span><br><span class="line">    this.legs = legs;</span><br><span class="line">    this.logInfo = function() &#123;</span><br><span class="line">        console.log(this === myCat); // =&gt; true</span><br><span class="line">        console.log(&apos;The &apos; + this.type + &apos; has &apos; + this.legs + &apos; legs&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var myCat = new Animal(&apos;Cat&apos;, 4);</span><br><span class="line">// logs &quot;The Cat has 4 legs&quot;</span><br><span class="line">setTimeout(myCat.logInfo.bind(myCat), 1000);&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>myCat.logInfo.bind(myCat)</code>返回一个跟<code>logInfo</code>执行效果一样的函数，但是它的<code>this</code>即使在函数调用情况下也是<code>myCat</code>。</p>
<h2 id="4-构造函数调用"><a href="#4-构造函数调用" class="headerlink" title="4. 构造函数调用"></a>4. 构造函数调用</h2><p>当 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener"><code>new</code></a>关键词紧接着函数对象,<code>(</code>, 一组逗号分隔的参数以及<code>)</code>时被调用，执行的是<strong>构造函数调用</strong>如<code>new RegExp(&#39;\\d&#39;)</code>。</p>
<p>这个例子声明了一个<code>Country</code>函数，并且将它作为一个构造函数调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function Country(name, traveled) &#123;</span><br><span class="line">    this.name = name ? name : &apos;United Kingdom&apos;;</span><br><span class="line">    this.traveled = Boolean(traveled); // transform to a boolean</span><br><span class="line">&#125;</span><br><span class="line">Country.prototype.travel = function() &#123;</span><br><span class="line">    this.traveled = true;</span><br><span class="line">&#125;;</span><br><span class="line">// Constructor invocation</span><br><span class="line">var france = new Country(&apos;France&apos;, false);</span><br><span class="line">// Constructor invocation</span><br><span class="line">var unitedKingdom = new Country;</span><br><span class="line"></span><br><span class="line">france.travel(); // Travel to France&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>new Country(&#39;France&#39;, false)</code>是<code>Country</code>函数的构造函数调用。它的执行结果是一个<code>name</code>属性为<code>&#39;France&#39;</code>的新的对象。 如果这个构造函数调用时不需要参数，那么括号可以省略：<code>new Country</code>。</p>
<p>从 ECMAScript 6 开始，JavaScript 允许用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener"><code>class</code></a>关键词来定义构造函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;class City &#123;</span><br><span class="line">  constructor(name, traveled) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.traveled = false;</span><br><span class="line">  &#125;</span><br><span class="line">  travel() &#123;</span><br><span class="line">    this.traveled = true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Constructor invocation</span><br><span class="line">var paris = new City(&apos;Paris&apos;, false);</span><br><span class="line">paris.travel();&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>new City(&#39;Paris&#39;)</code>是构造函数调用。这个对象的初始化由这个类中一个特殊的方法 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor" target="_blank" rel="noopener"><code>constructor</code></a>来处理。其中，<code>this</code>指向新创建的对象。</p>
<p>构造函数创建了一个新的空的对象，它从构造函数的原型继承了属性。构造函数的作用就是去初始化这个对象。 可能你已经知道了，在这种类型的调用中，上下文指向新创建的实例。这是我们下一章的主题。</p>
<p>当属性访问<code>myObject.myFunction</code>前面有一个<code>new</code>关键词时，JavaScript 会执行<strong>构造函数调用</strong>而<strong>不是</strong>原来的<strong>方法调用</strong>。例如<code>new myObject.myFunction()</code>：它相当于先用属性访问把方法提取出来<code>extractedFunction = myObject.myFunction</code>，然后利用把它作为构造函数创建一个新的对象： <code>new extractedFunction()</code>。</p>
<h3 id="4-1-构造函数中的this"><a href="#4-1-构造函数中的this" class="headerlink" title="4.1. 构造函数中的this"></a>4.1. 构造函数中的<code>this</code></h3><blockquote>
<p>在构造函数调用中<code>this</code>指向<strong>新创建的对象</strong></p>
</blockquote>
<p>构造函数调用的上下文是新创建的对象。它利用构造函数的参数初始化新的对象，设定属性的初始值，添加时间处理函数等等。</p>
<p>让我们来看看下面例子里的上下文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function Foo () &#123;</span><br><span class="line">    console.log(this instanceof Foo); // =&gt; true</span><br><span class="line">    this.property = &apos;Default Value&apos;;</span><br><span class="line">&#125;</span><br><span class="line">// Constructor invocation</span><br><span class="line">var fooInstance = new Foo();</span><br><span class="line">fooInstance.property; // =&gt; &apos;Default Value&apos;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>new Foo()</code>正在调用一个构造函数，它的上下文是<code>fooInstance</code>。其中，<code>Foo</code>被初始化了：<code>this.property</code>被赋予了一个默认值。</p>
<p>同样的情况在用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener"><code>class</code></a>语法（从 ES6 起）时也会发生，唯一的区别是初始化在<code>constructor</code>方法中进行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;class Bar &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        console.log(this instanceof Bar); // =&gt; true</span><br><span class="line">        this.property = &apos;Default Value&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Constructor invocation</span><br><span class="line">var barInstance = new Bar();</span><br><span class="line">barInstance.property; // =&gt; &apos;Default Value&apos;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>当<code>new Bar()</code>执行时，JavaScript 创建了一个空的对象，把它作为<code>constructor</code>方法的上下文。现在，你可以用<code>this</code>关键词给它添加属性：<code>this.property = &#39;Default Value&#39;</code>。</p>
<h3 id="4-2-陷阱-忘了new"><a href="#4-2-陷阱-忘了new" class="headerlink" title="4.2. 陷阱: 忘了new"></a>4.2. 陷阱: 忘了<code>new</code></h3><p>有些 JavaScirpt 函数不是只在作为构造函数调用的时候才创建新的对象，作为函数调用时也会，例如<code>RegExp</code>：</p>
<pre class="hljs javascript">var reg1 = new RegExp('\\w+');
var reg2 = RegExp('\\w+');

reg1 instanceof RegExp;      // => true
reg2 instanceof RegExp;      // => true
reg1.source === reg2.source; // => true</pre>

<p>当执行<code>new RegExp(&#39;\\w+&#39;)</code>和<code>RegExp(&#39;\\w+&#39;)</code>时，JavaScrit 会创建相同的正则表达式对象。</p>
<p>因为有些构造函数在<code>new</code>关键词缺失的情况下，可能跳过对象初始化，用函数调用创建对象会存在问题（不包括<a href="http://javascript.info/tutorial/factory-constructor-pattern" target="_blank" rel="noopener">工厂模式</a>）。 下面的例子就说明了这个问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function Vehicle(type, wheelsCount) &#123;</span><br><span class="line">    this.type = type;</span><br><span class="line">    this.wheelsCount = wheelsCount;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">// Function invocation</span><br><span class="line">var car = Vehicle(&apos;Car&apos;, 4);</span><br><span class="line">car.type;       // =&gt; &apos;Car&apos;</span><br><span class="line">car.wheelsCount // =&gt; 4</span><br><span class="line">car === window  // =&gt; true&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>Vehicle</code>是一个在上下文上设置了<code>type</code>跟<code>wheelsCount</code>属性的函数。当执行<code>Vehicle(&#39;Car&#39;, 4)</code>时，返回了一个<code>car</code>对象，它的属性是正确的：<code>car.type</code>是<code>&#39;Car&#39;</code>， <code>car.wheelsCount</code>是<code>4</code>。你可能以为它正确地创建并初始化了对象。 然而，在函数调用中，<code>this</code>是<code>window</code>对象 (见 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#21thisinfunctioninvocation" target="_blank" rel="noopener">2.1.</a>)，<code>Vehicle(&#39;Car&#39;, 4)</code>实际上是在给<code>window</code>对象设置属性 – 这是错的。它并没有创建一个新的对象。</p>
<p>当你希望调用构造函数时，确保你使用了<code>new</code>操作符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function Vehicle(type, wheelsCount) &#123;</span><br><span class="line">    if (!(this instanceof Vehicle)) &#123;</span><br><span class="line">        throw Error(&apos;Error: Incorrect invocation&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.type = type;</span><br><span class="line">    this.wheelsCount = wheelsCount;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">// Constructor invocation</span><br><span class="line">var car = new Vehicle(&apos;Car&apos;, 4);</span><br><span class="line">car.type               // =&gt; &apos;Car&apos;</span><br><span class="line">car.wheelsCount        // =&gt; 4</span><br><span class="line">car instanceof Vehicle // =&gt; true</span><br><span class="line"></span><br><span class="line">// Function invocation. Generates an error.</span><br><span class="line">var brokenCat = Vehicle(&apos;Broken Car&apos;, 3);&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>new Vehicle(&#39;Car&#39;, 4)</code>工作正常：因为<code>new</code>关键词出现在构造函数调用前，一个新的对象被创建并初始化。 在构造函数里我们添加了一个验证<code>this instanceof Vehicle</code>来确保执行的上下文是正确的对象类型。如果<code>this</code>不是<code>Vehicle</code>，那么就会报错。这样，如果执行<code>Vehicle(&#39;Broken Car&#39;, 3)</code>(没有<code>new</code>)，我们会得到一个异常：<code>Error: Incorrect invocation</code>。</p>
<h2 id="5-隐式调用"><a href="#5-隐式调用" class="headerlink" title="5. 隐式调用"></a>5. 隐式调用</h2><p>当函数被<code>.call()</code>或者<code>.apply()</code>调用时，执行的是<strong>隐式调用</strong>。</p>
<p>函数在 JavaScript 中是第一类对象，这意味着函数也是对象。它的类型是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noopener"><code>Function</code></a>。根据这个函数对象所拥有的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function#Methods" target="_blank" rel="noopener">方法列表</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener"><code>.call()</code></a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener"><code>.apply()</code></a>可以跟一个可变的上下文一起调用函数。</p>
<p>方法<code>.call(thisArg[, arg1[, arg2[, ...]]])</code>将接受的第一个参数<code>thisArg</code>作为调用时的上下文，<code>arg1, arg2, ...</code>这些则作为参数传入被调用的函数。方法<code>.apply(thisArg, [args])</code>将接受的第一个参数<code>thisArg</code>作为调用时的上下文，并且接受另一个<a href="http://www.2ality.com/2013/05/quirk-array-like-objects.html" target="_blank" rel="noopener">类似数组的对象</a><code>[args]</code>作为被调用函数的参数传入。</p>
<p>下面是一个隐式调用的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function increment(number) &#123;</span><br><span class="line">    return ++number;</span><br><span class="line">&#125;</span><br><span class="line">increment.call(undefined, 10);    // =&gt; 11</span><br><span class="line">increment.apply(undefined, [10]); // =&gt; 11&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>increment.call()</code>和<code>increment.apply()</code>都用参数<code>10</code>调用了这个自增函数。</p>
<p>这两者的主要区别是<code>.call()</code>接受一组参数，例如<code>myFunction.call(thisValue, &#39;value1&#39;, &#39;value2&#39;)</code>。然而<code>.apply()</code>接受的一组参数必须是一个类似数组的对象，例如<code>myFunction.apply(thisValue, [&#39;value1&#39;, &#39;value2&#39;])</code>。</p>
<h3 id="5-1-隐式调用中的this"><a href="#5-1-隐式调用中的this" class="headerlink" title="5.1. 隐式调用中的this"></a>5.1. 隐式调用中的<code>this</code></h3><blockquote>
<p>在隐式调用<code>.call()</code>或<code>.apply()</code>中，<code>this</code>是<strong>第一个参数</strong></p>
</blockquote>
<p>很明显，在隐式调用中，<code>this</code>是传入<code>.call()</code>或<code>.apply()</code>中的第一个参数。下面的这个例子就说明了这一点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;var rabbit = &#123; name: &apos;White Rabbit&apos; &#125;;</span><br><span class="line">function concatName(string) &#123;</span><br><span class="line">    console.log(this === rabbit); // =&gt; true</span><br><span class="line">    return string + this.name;</span><br><span class="line">&#125;</span><br><span class="line">// Indirect invocations</span><br><span class="line">concatName.call(rabbit, &apos;Hello &apos;);  // =&gt; &apos;Hello White Rabbit&apos;</span><br><span class="line">concatName.apply(rabbit, [&apos;Bye &apos;]); // =&gt; &apos;Bye White Rabbit&apos;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>当一个函数应该在特定的上下文中执行时，隐式调用就非常有用。例如为了解决方法调用时，<code>this</code>总是<code>window</code>或 strict 模式下的<code>undefined</code>的上下文问题 (见 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#23pitfallthisinaninnerfunction" target="_blank" rel="noopener">2.3.</a>)。隐式调用可以用于模拟在一个对象上调用某个方法（见之前的代码样例）。</p>
<p>另一个实际的例子是在 ES5 中，在创建的类的结构层次中中，调用父类的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function Runner(name) &#123;</span><br><span class="line">    console.log(this instanceof Rabbit); // =&gt; true</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function Rabbit(name, countLegs) &#123;</span><br><span class="line">    console.log(this instanceof Rabbit); // =&gt; true</span><br><span class="line">    // Indirect invocation. Call parent constructor.</span><br><span class="line">    Runner.call(this, name);</span><br><span class="line">    this.countLegs = countLegs;</span><br><span class="line">&#125;</span><br><span class="line">var myRabbit = new Rabbit(&apos;White Rabbit&apos;, 4);</span><br><span class="line">myRabbit; // &#123; name: &apos;White Rabbit&apos;, countLegs: 4 &#125;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>Rabbit</code>中的<code>Runner.call(this, name)</code>隐式调用了父类的函数来初始化这个对象。</p>
<h2 id="6-绑定函数"><a href="#6-绑定函数" class="headerlink" title="6. 绑定函数"></a>6. 绑定函数</h2><p><strong>绑定函数</strong>是一个与对象绑定的函数。通常它是通过在原函数上使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener"><code>.bind()</code></a>来创建的。原函数和绑定的函数共享代码跟作用域，但是在执行时有不同的上下文。</p>
<p>方法<code>.bind(thisArg[, arg1[, arg2[, ...]]])</code>接受第一个参数<code>thisArg</code>作为绑定函数执行时的上下文，并且它接受一组可选的参数 <code>arg1, arg2, ...</code>作为被调用函数的参数。它返回一个绑定了<code>thisArg</code>的新函数。</p>
<p>下面的代码创建了一个绑定函数并在之后调用它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function multiply(number) &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    return this * number;</span><br><span class="line">&#125;</span><br><span class="line">// create a bound function with context</span><br><span class="line">var double = multiply.bind(2);</span><br><span class="line">// invoke the bound function</span><br><span class="line">double(3);  // =&gt; 6</span><br><span class="line">double(10); // =&gt; 20&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>multiply.bind(2)</code>返回了一个新的函数对象<code>double</code>，<code>double</code>绑定了数字<code>2</code>。<code>multiply</code>跟<code>double</code>有相同的代码跟作用域。</p>
<p>跟<code>.apply()</code>以及<code>.call()</code>方法 (见 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#5indirectinvocation" target="_blank" rel="noopener">5.</a>) 马上调用函数不同，<code>.bind()</code>函数返回一个新的方法，它应该在之后被调用，只是<code>this</code>已经被提前设置好了。</p>
<h3 id="6-1-绑定函数中的this"><a href="#6-1-绑定函数中的this" class="headerlink" title="6.1. 绑定函数中的this"></a>6.1. 绑定函数中的<code>this</code></h3><blockquote>
<p>在调用绑定函数时，<code>this</code>是<code>.bind()</code>的<strong>第一个参数</strong>。</p>
</blockquote>
<p><code>.bind()</code>的作用是创建一个新的函数，它在被调用时的上下文是传入<code>.bind()</code>的第一个参数。它是一种非常强大的技巧，使你可以创建一个定义了<code>this</code>值的函数。</p>
<p>让我们来看看如何在一个绑定函数中设置<code>this</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs php&quot;&gt;var numbers = &#123;</span><br><span class="line">    array: [3, 5, 10],</span><br><span class="line">    getNumbers: function() &#123;</span><br><span class="line">        return this.array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// Create a bound function</span><br><span class="line">var boundGetNumbers = numbers.getNumbers.bind(numbers);</span><br><span class="line">boundGetNumbers(); // =&gt; [3, 5, 10]</span><br><span class="line">// Extract method from object</span><br><span class="line">var simpleGetNumbers = numbers.getNumbers;</span><br><span class="line">simpleGetNumbers(); // =&gt; undefined or throws an error in strict mode&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>numbers.getNumbers.bind(numbers)</code>返回了一个绑定了<code>number</code>对象的<code>boundGetNumbers</code>函数。<code>boundGetNumbers()</code>调用时的<code>this</code>是<code>number</code>对象，并能够返回正确的数组对象。<code>numbers.getNumbers</code>函数能在不绑定的情况下赋值给变量<code>simpleGetNumbers</code>。在之后的函数调用中，<code>simpleGetNumbers()</code>的<code>this</code>是<code>window</code>或者 strict 模式下的<code>undefined</code>，不是<code>number</code>对象 (见 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#32pitfallseparatingmethodfromitsobject" target="_blank" rel="noopener">3.2. 陷阱</a>)。在这个情况下，<code>simpleGetNumbers()</code>不会正确返回数组。</p>
<p><code>.bind()</code>永久性地建立了一个上下文的链接，并且会一直保持它。一个绑定函数不能通过<code>.call()</code>或者<code>.apply()</code>来改变它的上下文，甚至是再次绑定也不会有什么作用。 只有用绑定函数的构造函数调用方法能够改变上下文，但并不推荐这个方法（因为构造函数调用用的是_常规函数_而不是绑定函数）。 下面的例子声明了一个绑定函数，接着试图改变它预先定义好的上下文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function getThis() &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">var one = getThis.bind(1);</span><br><span class="line">// Bound function invocation</span><br><span class="line">one(); // =&gt; 1</span><br><span class="line">// Use bound function with .apply() and .call()</span><br><span class="line">one.call(2);  // =&gt; 1</span><br><span class="line">one.apply(2); // =&gt; 1</span><br><span class="line">// Bind again</span><br><span class="line">one.bind(2)(); // =&gt; 1</span><br><span class="line">// Call the bound function as a constructor</span><br><span class="line">new one(); // =&gt; Object&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>只有<code>new one()</code>改变了绑定函数的上下文，其他方式的调用中<code>this</code>总是等于<code>1</code>。</p>
<h2 id="7-箭头函数"><a href="#7-箭头函数" class="headerlink" title="7. 箭头函数"></a>7. 箭头函数</h2><p><strong>箭头函数</strong>被设计来以更简短的形式定义函数。并且能从<a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scoping" target="_blank" rel="noopener">词法</a>上绑定上下文。它能以下面的方式被使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;var hello = (name) =&gt; &#123;</span><br><span class="line">    return &apos;Hello &apos; + name;</span><br><span class="line">&#125;;</span><br><span class="line">hello(&apos;World&apos;); // =&gt; &apos;Hello World&apos;</span><br><span class="line">// Keep only even numbers</span><br><span class="line">[1, 2, 5, 6].filter(item =&gt; item % 2 === 0); // =&gt; [2, 6]&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>箭头函数带来了更轻量的语法，避免了冗长的<code>function</code>关键词。你甚至可以在函数只有一个语句的时候省略<code>return</code>。</p>
<p>因为箭头函数是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name" target="_blank" rel="noopener">匿名的</a>，这意味着它的<code>name</code>属性是个空字符串<code>&#39;&#39;</code>。这样一来，它就没有一个词法上的函数名（函数名在递归跟事件解绑时会比较有用）。同时，跟常规函数相反，它也不提供 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="noopener"><code>arguments</code></a>对象。但是，这在 ES6 中通过 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="noopener">rest parameters</a> 修复了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;var sumArguments = (...args) =&gt; &#123;</span><br><span class="line">   console.log(typeof arguments); // =&gt; &apos;undefined&apos;</span><br><span class="line">   return args.reduce((result, item) =&gt; result + item);</span><br><span class="line">&#125;;</span><br><span class="line">sumArguments.name      // =&gt; &apos;&apos;</span><br><span class="line">sumArguments(5, 5, 6); // =&gt; 16&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<h3 id="7-1-箭头函数中的this"><a href="#7-1-箭头函数中的this" class="headerlink" title="7.1. 箭头函数中的this"></a>7.1. 箭头函数中的<code>this</code></h3><blockquote>
<p><code>this</code>是箭头函数定义时<strong>封装好的上下文</strong></p>
</blockquote>
<p>箭头函数并不会创建它自己的上下文，它从它定义处的外部函数获得<code>this</code>上下文。下面的例子说明了这个上下文透明的特性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;class Point &#123;</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    log() &#123;</span><br><span class="line">        console.log(this === myPoint); // =&gt; true</span><br><span class="line">        setTimeout(()=&gt; &#123;</span><br><span class="line">            console.log(this === myPoint);      // =&gt; true</span><br><span class="line">            console.log(this.x + &apos;:&apos; + this.y); // =&gt; &apos;95:165&apos;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var myPoint = new Point(95, 165);</span><br><span class="line">myPoint.log();&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>setTimeout</code>在调用箭头函数时跟<code>log()</code>使用了相同的上下文 (<code>myPoint</code>对象)。正如所见，箭头函数从它定义处 “继承” 了函数的上下文。 如果在这个例子里尝试用常规函数，它会建立自己的上下文(<code>window</code>或 strict 模式下的<code>undefined</code>)。所以，为了让同样的代码能在函数表达式中正确运行，需要手动绑定上下文：<code>setTimeout(function() {...}.bind(this))</code>。这样一来就显得很啰嗦，不如用箭头函数来得简短。</p>
<p>如果箭头函数定义在最上层的作用域（在所有函数之外），那么上下文就总是全局对象（浏览器中的<code>window</code>对象）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs coffeescript&quot;&gt;var getContext = () =&gt; &#123;</span><br><span class="line">   console.log(this === window); // =&gt; true</span><br><span class="line">   return this;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(getContext() === window); // =&gt; true&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>箭头函数会<strong>一劳永逸</strong>地绑定词法作用域。即使使用修改上下文的方法，<code>this</code>也不能被改变：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs cs&quot;&gt;var numbers = [1, 2];</span><br><span class="line">(function() &#123;</span><br><span class="line">    var get = () =&gt; &#123;</span><br><span class="line">        console.log(this === numbers); // =&gt; true</span><br><span class="line">        return this;</span><br><span class="line">    &#125;;</span><br><span class="line">    console.log(this === numbers); // =&gt; true</span><br><span class="line">    get(); // =&gt; [1, 2]</span><br><span class="line">    // Use arrow function with .apply() and .call()</span><br><span class="line">    get.call([0]);  // =&gt; [1, 2]</span><br><span class="line">    get.apply([0]); // =&gt; [1, 2]</span><br><span class="line">    // Bind</span><br><span class="line">    get.bind([0])(); // =&gt; [1, 2]</span><br><span class="line">&#125;).call(numbers);&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>一个函数表达式通过<code>.call(numbers)</code>被隐式调用了，这使得这个调用的<code>this</code>变成了<code>numbers</code>。这样一来，箭头函数<code>get</code>的<code>this</code>也变成了<code>numbers</code>，因为它是从词法上获得的上下文。</p>
<p>无论<code>get</code>是怎么被调用的，它一直保持了一开始的上下文<code>numbers</code>。用其他上下文的隐式调用 (通过<code>.call()</code>或<code>.apply()</code>) 或者重新绑定 (通过<code>.bind()</code>) 都不会起作用</p>
<p>箭头函数不能用作构造函数。如果像构造函数一样调用<code>new get()</code>， JavaScript 会抛出异常：<code>TypeError: get is not a constructor</code>。</p>
<h3 id="7-2-陷阱-用箭头函数定义方法"><a href="#7-2-陷阱-用箭头函数定义方法" class="headerlink" title="7.2. 陷阱: 用箭头函数定义方法"></a>7.2. 陷阱: 用箭头函数定义方法</h3><p>你可能想用箭头函数在一个对象上定义方法。这很合情合理：箭头函数的定义相比于<a href="https://developer.mozilla.org/en/docs/web/JavaScript/Reference/Operators/function" target="_blank" rel="noopener">函数表达式</a>短得多：例如<code>(param) =&gt; {...}</code>而不是<code>function(param) {..}</code>。</p>
<p>这个例子用箭头函数在<code>Period</code>类上定义了<code>format()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function Period (hours, minutes) &#123;</span><br><span class="line">    this.hours = hours;</span><br><span class="line">    this.minutes = minutes;</span><br><span class="line">&#125;</span><br><span class="line">Period.prototype.format = () =&gt; &#123;</span><br><span class="line">    console.log(this === window); // =&gt; true</span><br><span class="line">    return this.hours + &apos; hours and &apos; + this.minutes + &apos; minutes&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">var walkPeriod = new Period(2, 30);</span><br><span class="line">walkPeriod.format(); // =&gt; &apos;undefined hours and undefined minutes&apos;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>由于<code>format</code>是一个箭头函数，并且它定义在全局上下文（最顶层的作用域）中，它的<code>this</code>指向<code>window</code>对象。即使<code>format</code>作为方法在一个对象上被调用如<code>walkPeriod.format()</code>，<code>window</code>仍然是这次调用的上下文。之所以会这样是因为箭头函数有静态的上下文，并不会随着调用方式的改变而改变。</p>
<p>函数表达式可以解决这个问题，因为一个常规的函数会随着调用方法而改变其上下文:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs javascript&quot;&gt;function Period (hours, minutes) &#123;</span><br><span class="line">    this.hours = hours;</span><br><span class="line">    this.minutes = minutes;</span><br><span class="line">&#125;</span><br><span class="line">Period.prototype.format = function() &#123;</span><br><span class="line">    console.log(this === walkPeriod); // =&gt; true</span><br><span class="line">    return this.hours + &apos; hours and &apos; + this.minutes + &apos; minutes&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">var walkPeriod = new Period(2, 30);</span><br><span class="line">walkPeriod.format(); // =&gt; &apos;2 hours and 30 minutes&apos;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p><code>walkPeriod.format()</code>是一个对象上的方法调用 (见 <a href="https://rainsoft.io/gentle-explanation-of-this-in-javascript/#31thisinmethodinvocation" target="_blank" rel="noopener">3.1.</a>)，它的上下文是<code>walkPeriod</code>对象。<code>this.hours</code>等于<code>2</code>，<code>this.minutes</code>等于<code>30</code>，所以这个方法返回了正确的结果：<code>&#39;2 hours and 30 minutes&#39;</code>。</p>
<h2 id="8-结论"><a href="#8-结论" class="headerlink" title="8. 结论"></a>8. 结论</h2><p>因为函数调用对<code>this</code>有最大的影响，从现在起，<strong>不要</strong>再问你自己：</p>
<blockquote>
<p><code>this</code>是从哪里来的？</p>
</blockquote>
<p>而<strong>要</strong>问自己：</p>
<blockquote>
<p>函数是怎么<code>被调用</code>的？</p>
</blockquote>
<p>对于箭头函数，问问你自己：</p>
<blockquote>
<p>在这个箭头函数被<code>定义</code>的地方，<code>this</code>是什么？</p>
</blockquote>
<p>这是处理<code>this</code>时的正确想法，它们可以让你免于头痛。</p>
<p>[!转载]：<a href="https://www.w3cplus.com/javascript/gentle-explanation-of-this-in-javascript.html" target="_blank" rel="noopener">https://www.w3cplus.com/javascript/gentle-explanation-of-this-in-javascript.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE组件数据传递</title>
    <url>/2019/11/19/VUE%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p>在项目中使用组件，目的一般就是提高代码复用率，增强模块化，从而降低开发成本。在文章结尾处，我们提到了 Vue 中组合组件，就是<code>A</code>组件中包含了<code>B</code>组件。而组件与组件之间的相互使用避免不了数据之间的传递。那么 Vue 中组件的数据是如何传递的呢？这就是这一节将要了解和学习的内容。</p>
<a id="more"></a>
<p>首先要说明，组件数据传递不同于 Vue 全局的数据传递，<strong>组件实例的数据作用域名是孤立的</strong>，这里的孤立并不仅仅在组件内独立，而且是指上下层之间的数据隔离，<strong>即不能在子组件的模板内直接引用父组件的数据</strong>。如果要把数据从父组件传递到子组件，就需要使用<code>props</code>属性。这是父组件用来传递数据的一个自定义属性。也就是说，如果要彻底了解清楚 Vue 组件的数据传递，就很有必要了解清楚<code>props</code>属性。</p>
<h2 id="组件数据流向"><a href="#组件数据流向" class="headerlink" title="组件数据流向"></a>组件数据流向</h2><p>在 Vue 的官方文档中提到，在 Vue 中，父子组件的关系总结为：<strong><code>prop</code>向下传递，事件向上传递。</strong>父组件通过<code>prop</code>给子组件下发数据，子组件通过事件给父组件发送消息。如下图所示：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1802/vue-component-8.png" alt></p>
<p>常把这种数据流称之为单向数据流。<code>prop</code>是单向绑定的：<strong>当父组件的属性变化时，将传给子组件，但是反过来不会</strong>。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。</p>
<p>另外，每次父组件更新时，子组件的所有<code>prop</code>都会更新为最新值。这意味着你不应该在子组件内部改变<code>prop</code>。如果你这么做了，Vue 会在控制台给出警告。用一张更细化的图来表示 Vue 组件系统中父子组件的数据流动：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1802/vue-component-prop-1.png" alt></p>
<p>使用<code>props</code>向子组件传递数据，首先要在子组件中定义子组件能接受的<code>props</code>，然后在父组件中子组件的自定义元素上将数据传递给它。</p>
<h2 id="props-的使用"><a href="#props-的使用" class="headerlink" title="props 的使用"></a>props 的使用</h2><p>前面提到过了，<strong>组件实例的作用域是孤立的</strong>。父组件需要通过<code>props</code>把数据传给子组件。要真正了解其中的原委，就很有必要了解清楚<code>props</code>的使用。那么我们从一些简单的示例开始吧。</p>
<h3 id="props-基础示例"><a href="#props-基础示例" class="headerlink" title="props 基础示例"></a>props 基础示例</h3><p>首先来创建一个子组件<code>child</code>，并且在 Vue 的实例中定义了<code>data</code>选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs cs&quot;&gt;let parent = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name: &apos;w3cplus&apos;,</span><br><span class="line">            age: 7</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        &apos;child&apos;: &#123;</span><br><span class="line">            template: &apos;#child&apos;,</span><br><span class="line">            props: [&apos;myName&apos;, &apos;myAge&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>这里直接把 Vue 实例<code>parent</code>当作组件<code>child</code>的父组件。如果我们想要使用父组件的数据，则必须先在子组件中定义<code>props</code>，即：<code>props:[&#39;myName&#39;, &#39;myAge&#39;]</code>。</p>
<p>接下来定义<code>child</code>组件的模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs xml&quot;&gt;&lt;template id=&quot;child&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">        &lt;h3&gt;子组件child数据&lt;/h3&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;label&gt;姓名&lt;/label&gt;</span><br><span class="line">                &lt;span&gt;&#123;&#123; myName &#125;&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;label&gt;年龄&lt;/label&gt;</span><br><span class="line">                &lt;span&gt;&#123;&#123; myAge &#125;&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>将父组件<code>parent</code>的<code>data</code>通过已定义好的<code>props</code>属性传递给子组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs ruby&quot;&gt;&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;child :my-&gt;&lt;/child&gt;</span><br><span class="line">&lt;/div&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>给上面的示例，添加一点 CSS，最终看到的效果如下：</p>
<iframe src="//codepen.io/airen/embed/QQKKqg?height=400&amp;theme-id=0&amp;slug-hash=QQKKqg&amp;default-tab=result&amp;user=airen" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" class="sr-rd-content-nobeautify"></iframe>

<blockquote>
<p><strong>注意：</strong>由于 HTML 特性不区分大小写，在子组件定义<code>prop</code>时，使用了驼峰式大小写（camelCase）命名法。驼峰式大小写的<code>prop</code>用于特性时，需要转为短横线隔开（kebab-case）。例如，在<code>prop</code>中定义的<code>myName</code>，在用作特性时需要转换为<code>my-name</code>。</p>
</blockquote>
<p>用下图简单的剖析一下父组件<code>parent</code>是如何将数据传给子组件<code>child</code>，或许这样对于初学者更易于理解：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1802/vue-component-prop-2.png" alt></p>
<p>在父组件使用子组件时，通过以下语法将数据传递给子组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs xml&quot;&gt;&lt;child :子组件的prop=&quot;父组件数据属性&quot;&gt;&lt;/child&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>:</code>其实相当于<code>v-bind</code>，也就是 Vue 中的<code>v-bind</code>指令。这是属于动态绑定，让它的值被当作 JavaScript 表达式计算。稍后会做相关的介绍。</p>
</blockquote>
<h3 id="prop-的绑定类型"><a href="#prop-的绑定类型" class="headerlink" title="prop 的绑定类型"></a>prop 的绑定类型</h3><p>在 Vue 中的<code>prop</code>绑定主要有单向绑定和双向绑定。先来了解一下单向绑定。</p>
<h4 id="单向绑定"><a href="#单向绑定" class="headerlink" title="单向绑定"></a>单向绑定</h4><p>通过上面的示例，咱们简单的了解了怎么将父组件数据传递给子组件。而且在 Vue 2.0 中组件的<code>props</code>的数据流动改为了单向流动，即<strong>只能由组件外（调用组件方）通过组件的 DOM 属性<code>attribute</code>传递<code>props</code>给组件内，组件内只能被动接受组件外传递过来的数据，并且在组件内，不能修改由外层传来的<code>props</code>数据</strong>。</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1802/vue-component-prop-3.png" alt></p>
<p>但很多时候我们还是会修改子组件数据，那么问题来了，如果子组件修改了数据，对父组件是否有影响呢？我们基于上面的示例，做一下相应的调整：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs xml&quot;&gt;&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;h3&gt;父组件Parent数据&lt;/h3&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;label&gt;姓名:&lt;/label&gt;</span><br><span class="line">                &lt;span&gt;&#123;&#123; name &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; v-model=&quot;name&quot; /&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;label&gt;年龄:&lt;/label&gt;</span><br><span class="line">                &lt;span&gt;&#123;&#123; age &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; v-model=&quot;age&quot; /&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;child :my-&gt;&lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;child&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">        &lt;h3&gt;子组件child数据&lt;/h3&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;label&gt;姓名&lt;/label&gt;</span><br><span class="line">                &lt;span&gt;&#123;&#123; myName &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; v-model=&quot;myName&quot; /&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;label&gt;年龄&lt;/label&gt;</span><br><span class="line">                &lt;span&gt;&#123;&#123; myAge &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; v-model=&quot;myAge&quot; /&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>看到的效果如下：</p>
<iframe src="//codepen.io/airen/embed/JpbYeM?height=400&amp;theme-id=0&amp;slug-hash=JpbYeM&amp;default-tab=result&amp;user=airen" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" class="sr-rd-content-nobeautify"></iframe>

<p>在这个 Demo 中我们来做两个小修改。首先修改父组件中的数据：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1802/vue-component-prop-4.gif" alt></p>
<p>从上面修改父组件数据得到的效果可以告诉我们：<strong>修改父组件的数据将会影响子组件，子组件的数据也会对应的修改</strong>。</p>
<p>接下来再反过来，修改子组件的数据：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1802/vue-component-prop-5.gif" alt></p>
<p>从效果中可以看出：<strong>修改子组件数据并不会影响父组件的数据</strong>。</p>
<blockquote>
<p><code>prop</code>默认是单向绑定：<strong>当父组件的属性变化时，将传给子组件，但反过来不会。这是为了防止子组件无意修改了父组件的状态</strong>。</p>
</blockquote>
<p>用一个更真实的示例来进一步的阐述。假设我们要做一个 iOS 风格的开关按钮：</p>
<ul>
<li>点击按钮实现 “开 / 关” 状态切换</li>
<li>不点击按钮，也可以通过外部修改数据切换 “开 / 关” 状态</li>
</ul>
<p>代码大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs cs&quot;&gt;&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;switch-button :result=&quot;result&quot;&gt;&lt;/switch-button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;switch-button&quot; @click=&quot;change&quot; :class=&quot;result ? &apos;on&apos; : &apos;off&apos;&quot;&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; result ? &quot;开&quot; : &quot;关&quot; &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;switch-button&apos;, &#123;</span><br><span class="line">    template: `</span><br><span class="line">        &lt;div class=&quot;switch-button&quot; @click=&quot;change&quot; :class=&quot;result ? &apos;on&apos; : &apos;off&apos;&quot;&gt;</span><br><span class="line">            &lt;span&gt;&#123;&#123; result ? &quot;开&quot; : &quot;关&quot; &#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    `,</span><br><span class="line">    props: [&apos;result&apos;],</span><br><span class="line">    methods: &#123;</span><br><span class="line">        change: function () &#123;</span><br><span class="line">            this.result = !this.result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            result: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        change: function () &#123;</span><br><span class="line">            this.result = !this.result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>上面的示例得到的效果如下：</p>
<iframe src="//codepen.io/airen/embed/WMorBE?height=400&amp;theme-id=0&amp;slug-hash=WMorBE&amp;default-tab=result&amp;user=airen" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" class="sr-rd-content-nobeautify"></iframe>

<p>来操作一下两个切换按钮的效果：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1802/vue-component-prop-6.gif" alt></p>
<p>虽然效果上没有问题，但事实上，当我们点击 “开关组件” 时，将会发出一个警告信息：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1802/vue-component-prop-7.png" alt></p>
<p>再次验证：<strong>组件内不能修改<code>props</code>的值，同时修改的值也不会同步到组件外层，即调用组件方不知道组件内部当前的状态是什么。</strong></p>
<blockquote>
<p>至于这个 Demo 的操作会发出警告信息，以及怎么处理，这里先不说了。后续我们将会深入了解怎么处理这个 Demo 的警告信息。</p>
</blockquote>
<h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h4><p>咱们回到前面的示例中来。前面的示例演示告诉我们，父组件和子组件的操作：</p>
<blockquote>
<p><strong>修改父组件的数据将会影响子组件，子组件的数据也会对应的修改；修改子组件数据并不会影响父组件的数据</strong>。</p>
</blockquote>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1802/vue-component-prop-8.gif" alt></p>
<p>要改变这一状态。可以通过<code>props</code>的双向绑定来完成。在 Vue 中，可以使用<code>.sync</code>显式地指定双向绑定，这样能让<strong>子组件的数据修改会回传给父组件</strong>。</p>
<p>在上面的示例中调用子组件时，像下面这样操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs perl&quot;&gt;&lt;child v-bind:my-name.sync=&quot;name&quot; v-bind:my-age.sync=&quot;age&quot;&gt;&lt;/child&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<iframe src="//codepen.io/airen/embed/rJWMZK?height=400&amp;theme-id=0&amp;slug-hash=rJWMZK&amp;default-tab=result&amp;user=airen" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" class="sr-rd-content-nobeautify"></iframe>

<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1802/vue-component-prop-9.gif" alt></p>
<p>这正是 Vue 1.x 中的 <code>.sync</code> 修饰符所提供的功能。当一个子组件改变了一个带 <code>.sync</code> 的 <code>prop</code> 的值时，这个变化也会同步到父组件中所绑定的值。这很方便，但也会导致问题，因为它破坏了单向数据流。由于子组件改变 <code>prop</code> 的代码和普通的状态改动代码毫无区别，当光看子组件的代码时，你完全不知道它何时悄悄地改变了父组件的状态。这在 debug 复杂结构的应用时会带来很高的维护成本。</p>
<p>上面所说的正是我们在 2.0 中移除 <code>.sync</code> 的理由。但是在 2.0 发布之后的实际应用中，我们发现 <code>.sync</code> 还是有其适用之处，比如在开发可复用的组件库时。我们需要做的只是让子组件改变父组件状态的代码更容易被区分。</p>
<p>从 2.3.0 起我们重新引入了 <code>.sync</code> 修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 <code>v-on</code> 监听器。</p>
<p>如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs xml&quot;&gt;&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>会被扩展为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs ruby&quot;&gt;&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>当子组件需要更新 <code>foo</code> 的值时，它需要显式地触发一个更新事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;hljs bash&quot;&gt;this.$emit(&apos;update:foo&apos;, newValue)&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>感觉<code>props</code>双向绑定还是蛮复杂的。这也正是前面把切换按钮示例中解决警告信息留下来没有阐述的原因之一。下一节将学习解决父子组件数据和<code>props</code>的双向绑定。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这篇文章的学习，了解了在 Vue 2.0 中，父子组件的数据流是单向的。即：<code>prop</code>默认是单向绑定，<strong>当父组件的属性变化时，将传给子组件，但反过来不会。这是为了防止子组件无意修改了父组件的状态</strong>。而很多时候我们又需要子组件修改数据时，在父组件中要有所反应。这个时候就需要涉及到双向数据绑定。在下一节中，将学习 Vue 2.0 中的数据双向绑定。</p>
<p>[!转载]：<a href="//www.w3cplus.com/vue/component-data-and-props-part1.html">https://www.w3cplus.com/vue/component-data-and-props-part1.html</a><a href="https://m2film.dk/eshop/collections/womens" target="_blank" rel="noopener">Women’s Clothing, Footwear &amp; Accessories</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 命令大全</title>
    <url>/2019/11/19/Git-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="Git-命令大全"><a href="#Git-命令大全" class="headerlink" title="Git 命令大全"></a>Git 命令大全</h1><a id="more"></a>
<h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>配置 Git 的相关参数。</p>
<p>Git 一共有 3 个配置文件：</p>
<ol>
<li>仓库级的配置文件：在仓库的 <code>.git/.gitconfig</code>，该配置文件只对所在的仓库有效。  </li>
<li>全局配置文件：Mac 系统在 <code>~/.gitconfig</code>，Windows 系统在 <code>C:\Users\&lt;用户名&gt;\.gitconfig</code>。  </li>
<li>系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 <code>/usr/local/git</code>）的 <code>etc</code> 文件夹中的 <code>gitconfig</code>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看配置信息</span><br><span class="line"># --local：仓库级，--global：全局级，--system：系统级</span><br><span class="line">$ git config &lt;--local | --global | --system&gt; -l</span><br><span class="line"></span><br><span class="line"># 查看当前生效的配置信息</span><br><span class="line">$ git config -l</span><br><span class="line"></span><br><span class="line"># 编辑配置文件</span><br><span class="line"># --local：仓库级，--global：全局级，--system：系统级</span><br><span class="line">$ git config &lt;--local | --global | --system&gt; -e</span><br><span class="line"></span><br><span class="line"># 添加配置项</span><br><span class="line"># --local：仓库级，--global：全局级，--system：系统级</span><br><span class="line">$ git config &lt;--local | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"># 获取配置项</span><br><span class="line">$ git config &lt;--local | --global | --system&gt; --get &lt;name&gt;</span><br><span class="line"></span><br><span class="line"># 删除配置项</span><br><span class="line">$ git config &lt;--local | --global | --system&gt; --unset &lt;name&gt;</span><br><span class="line"></span><br><span class="line"># 配置提交记录中的用户信息</span><br><span class="line">$ git config --global user.name &lt;用户名&gt;</span><br><span class="line">$ git config --global user.email &lt;邮箱地址&gt;</span><br><span class="line"></span><br><span class="line"># 更改Git缓存区的大小</span><br><span class="line"># 如果提交的内容较大，默认缓存较小，提交会失败</span><br><span class="line"># 缓存大小单位：B，例如：524288000（500MB）</span><br><span class="line">$ git config --global http.postBuffer &lt;缓存大小&gt;</span><br><span class="line"></span><br><span class="line"># 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态</span><br><span class="line">$ git config --global color.ui true</span><br><span class="line"></span><br><span class="line"># 配置可以缓存密码，默认缓存时间15分钟</span><br><span class="line">$ git config --global credential.helper cache</span><br><span class="line"></span><br><span class="line"># 配置密码的缓存时间</span><br><span class="line"># 缓存时间单位：秒</span><br><span class="line">$ git config --global credential.helper &apos;cache --timeout=&lt;缓存时间&gt;&apos;</span><br><span class="line"></span><br><span class="line"># 配置长期存储密码</span><br><span class="line">$ git config --global credential.helper store</span><br></pre></td></tr></table></figure>

<h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>从远程仓库克隆一个版本库到本地。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span><br><span class="line">$ git clone &lt;远程仓库的网址&gt;</span><br><span class="line"></span><br><span class="line"># 指定本地仓库的目录</span><br><span class="line">$ git clone &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"># -b 指定要克隆的分支，默认是master分支</span><br><span class="line">$ git clone &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 初始化本地仓库，在当前目录下生成 .git 文件夹</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>查看本地仓库的状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看本地仓库的状态</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 以简短模式查看本地仓库的状态</span><br><span class="line"># 会显示两列，第一列是文件的状态，第二列是对应的文件</span><br><span class="line"># 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中</span><br><span class="line">$ git status -s</span><br></pre></td></tr></table></figure>

<h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p>操作远程库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出已经存在的远程仓库</span><br><span class="line">$ git remote</span><br><span class="line"></span><br><span class="line"># 列出远程仓库的详细信息，在别名后面列出URL地址</span><br><span class="line">$ git remote -v</span><br><span class="line">$ git remote --verbose</span><br><span class="line"></span><br><span class="line"># 添加远程仓库</span><br><span class="line">$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;</span><br><span class="line"></span><br><span class="line"># 修改远程仓库的别名</span><br><span class="line">$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;</span><br><span class="line"></span><br><span class="line"># 删除指定名称的远程仓库</span><br><span class="line">$ git remote remove &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"># 修改远程仓库的 URL 地址</span><br><span class="line">$ git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p>操作 Git 的分支命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出本地的所有分支，当前所在分支以 &quot;*&quot; 标出</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出本地的所有分支并显示最后一次提交，当前所在分支以 &quot;*&quot; 标出</span><br><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line"># 创建新分支，新的分支基于上一次提交建立</span><br><span class="line">$ git branch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"># 修改分支名称</span><br><span class="line"># 如果不指定原分支名称则为当前所在分支</span><br><span class="line">$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"># 强制修改分支名称</span><br><span class="line">$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"></span><br><span class="line"># 删除指定的本地分支</span><br><span class="line">$ git branch -d &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"># 强制删除指定的本地分支</span><br><span class="line">$ git branch -D &lt;分支名称&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>检出命令，用于创建、切换分支等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 切换到已存在的指定分支</span><br><span class="line">$ git checkout &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"># 创建并切换到指定的分支，保留所有的提交记录</span><br><span class="line"># 等同于 &quot;git branch&quot; 和 &quot;git checkout&quot; 两个命令合并</span><br><span class="line">$ git checkout -b &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"># 创建并切换到指定的分支，删除所有的提交记录</span><br><span class="line">$ git checkout --orphan &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"># 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</span><br><span class="line">$ git checkout &lt;文件路径&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p>把已经提交的记录合并到当前分支。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 把已经提交的记录合并到当前分支</span><br><span class="line">$ git cherry-pick &lt;commit ID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 把指定的文件添加到暂存区中</span><br><span class="line">$ git add &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"># 添加所有修改、已删除的文件到暂存区中</span><br><span class="line">$ git add -u [&lt;文件路径&gt;]</span><br><span class="line">$ git add --update [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"># 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</span><br><span class="line">$ git add -A [&lt;文件路径&gt;]</span><br><span class="line">$ git add --all [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"># 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</span><br><span class="line">$ git add -i [&lt;文件路径&gt;]</span><br><span class="line">$ git add --interactive [&lt;文件路径&gt;]</span><br></pre></td></tr></table></figure>

<h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>将暂存区中的文件提交到本地仓库中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"># 把暂存区中的文件提交到本地仓库中并添加描述信息</span><br><span class="line">$ git commit -m &quot;&lt;提交的描述信息&gt;&quot;</span><br><span class="line"></span><br><span class="line"># 把所有修改、已删除的文件提交到本地仓库中</span><br><span class="line"># 不包括未被版本库跟踪的文件，等同于先调用了 &quot;git add -u&quot;</span><br><span class="line">$ git commit -a -m &quot;&lt;提交的描述信息&gt;&quot;</span><br><span class="line"></span><br><span class="line"># 修改上次提交的描述信息</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p>从远程仓库获取最新的版本到本地的 tmp 分支上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将远程仓库所有分支的最新版本全部取回到本地</span><br><span class="line">$ git fetch &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"># 将远程仓库指定分支的最新版本取回到本地</span><br><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>合并分支。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 把指定的分支合并到当前所在的分支下</span><br><span class="line">$ git merge &lt;分支名称&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>比较版本之间的差异。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 比较暂存区中的文件和上次提交时的差异</span><br><span class="line">$ git diff --cached</span><br><span class="line">$ git diff --staged</span><br><span class="line"></span><br><span class="line"># 比较当前文件和上次提交时的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 查看从指定的版本之后改动的内容</span><br><span class="line">$ git diff &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"># 比较两个分支之间的差异</span><br><span class="line">$ git diff &lt;分支名称&gt; &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"># 查看两个分支分开后各自的改动内容</span><br><span class="line">$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>从远程仓库获取最新版本并合并到本地。<br>首先会执行 <code>git fetch</code>，然后执行 <code>git merge</code>，把获取的分支的 HEAD 合并到当前分支。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从远程仓库获取最新版本。</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>

<h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>把本地仓库的提交推送到远程仓库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 把本地仓库的分支推送到远程仓库的指定分支</span><br><span class="line">$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"># 删除指定的远程仓库的分支</span><br><span class="line">$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;</span><br><span class="line">$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>显示提交的记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打印所有的提交记录</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 打印从第一次提交到指定的提交的记录</span><br><span class="line">$ git log &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"># 打印指定数量的最新提交的记录</span><br><span class="line">$ git log -&lt;指定的数量&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>还原提交记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--soft参数</span><br><span class="line">   仅仅在本地库移动head指针</span><br><span class="line">--mixed参数</span><br><span class="line">   在本地库移动head指针</span><br><span class="line">   重置暂存区</span><br><span class="line">--hard参数</span><br><span class="line">   在本地库移动指针</span><br><span class="line">   重置暂存区</span><br><span class="line">   处置工作区</span><br><span class="line">--------------------------------------------------</span><br><span class="line"># 重置暂存区，但文件不受影响</span><br><span class="line"># 相当于将用 &quot;git add&quot; 命令更新到暂存区的内容撤出暂存区，可以指定文件</span><br><span class="line"># 没有指定 commit ID 则默认为当前 HEAD</span><br><span class="line">$ git reset [&lt;文件路径&gt;]</span><br><span class="line">$ git reset --mixed [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span><br><span class="line">$ git reset &lt;commit ID&gt;</span><br><span class="line">$ git reset --mixed &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span><br><span class="line"># 相当于调用 &quot;git reset --mixed&quot; 命令后又做了一次 &quot;git add&quot;</span><br><span class="line">$ git reset --soft &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了</span><br><span class="line">$ git reset --hard &lt;commit ID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p>生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成一个新的提交来撤销某次提交</span><br><span class="line">$ git revert &lt;commit ID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><p>操作标签的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打印所有的标签</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录</span><br><span class="line">$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]</span><br><span class="line"></span><br><span class="line"># 添加带有描述信息的附注标签，可以指定之前的提交记录</span><br><span class="line">$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]</span><br><span class="line"></span><br><span class="line"># 切换到指定的标签</span><br><span class="line">$ git checkout &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"># 查看标签的信息</span><br><span class="line">$ git show &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"># 删除指定的标签</span><br><span class="line">$ git tag -d &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"># 将指定的标签提交到远程仓库</span><br><span class="line">$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"># 将本地所有的标签全部提交到远程仓库</span><br><span class="line">$ git push &lt;远程仓库的别名&gt; –tags</span><br></pre></td></tr></table></figure>

<h2 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h2><p>重命名文件或者文件夹。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 重命名指定的文件或者文件夹</span><br><span class="line">$ git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>删除文件或者文件夹。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 移除跟踪指定的文件，并从本地仓库的文件夹中删除</span><br><span class="line">$ git rm &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"># 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除</span><br><span class="line">$ git rm -r &lt;文件夹路径&gt;</span><br><span class="line"></span><br><span class="line"># 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件</span><br><span class="line">$ git rm --cached</span><br></pre></td></tr></table></figure>

<h2 id="Git-操作场景示例"><a href="#Git-操作场景示例" class="headerlink" title="Git 操作场景示例"></a>Git 操作场景示例</h2><h3 id="1-删除掉本地不存在的远程分支"><a href="#1-删除掉本地不存在的远程分支" class="headerlink" title="1. 删除掉本地不存在的远程分支"></a>1. 删除掉本地不存在的远程分支</h3><p>多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 <code>git branch --all</code> 依然会显示该远程分支，可使用下列的命令进行删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用 pull 命令，添加 -p 参数</span><br><span class="line">$ git pull -p</span><br><span class="line"></span><br><span class="line"># 等同于下面的命令</span><br><span class="line">$ git fetch -p</span><br><span class="line">$ git fetch --prune origin</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>块元素、内联元素、内联块元素</title>
    <url>/2019/11/19/%E5%9D%97%E5%85%83%E7%B4%A0%E3%80%81%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0%E3%80%81%E5%86%85%E8%81%94%E5%9D%97%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h4 id="●CSS-中，html-中的标签元素大体被分为三种不同的类型：块状元素、内联元素-又叫行内元素-和内联块状元素。"><a href="#●CSS-中，html-中的标签元素大体被分为三种不同的类型：块状元素、内联元素-又叫行内元素-和内联块状元素。" class="headerlink" title="●CSS 中，html 中的标签元素大体被分为三种不同的类型：块状元素、内联元素 (又叫行内元素) 和内联块状元素。"></a>●CSS 中，html 中的标签元素大体被分为三种不同的类型：块状元素、内联元素 (又叫行内元素) 和内联块状元素。</h4><a id="more"></a>
<h4 id="常用的块状元素有："><a href="#常用的块状元素有：" class="headerlink" title="常用的块状元素有："></a>常用的块状元素有：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;-&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;</span><br></pre></td></tr></table></figure>

<h4 id="常用的内联元素有："><a href="#常用的内联元素有：" class="headerlink" title="常用的内联元素有："></a>常用的内联元素有：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</span><br></pre></td></tr></table></figure>

<h4 id="常用的内联块状元素有："><a href="#常用的内联块状元素有：" class="headerlink" title="常用的内联块状元素有："></a>常用的内联块状元素有：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img&gt;、&lt;input&gt;</span><br></pre></td></tr></table></figure>

<h2 id="·-元素分类-–-块级元素"><a href="#·-元素分类-–-块级元素" class="headerlink" title="· 元素分类 – 块级元素"></a>· 元素分类 – 块级元素</h2><p>什么是块级元素？在 html 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;</span><br></pre></td></tr></table></figure>

<p>就是块级元素。设置 display:block 就是将元素显示为块级元素。如下代码就是将<strong>内联元素 a</strong> 转换为<strong>块状元素</strong>，从而使 a 元素具有<strong>块状元素</strong>特点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#123;display:block;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>块级元素特点：</strong></p>
<blockquote>
<p>1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）<br>2、元素的高度、宽度、行高以及顶和底边距都可设置。<br>3、元素宽度在不设置的情况下，是它本身父容器的 100%（和父元素的宽度一致），除非设定一个宽度。</p>
</blockquote>
<h2 id="·-元素分类-–-内联元素"><a href="#·-元素分类-–-内联元素" class="headerlink" title="· 元素分类 – 内联元素"></a>· 元素分类 – 内联元素</h2><p>在 html 中，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、 &lt;strong&gt; 和&lt;em&gt;</span><br></pre></td></tr></table></figure>

<p>就是典型的<strong>内联元素</strong>（<strong>行内元素</strong>）（inline）元素。当然<strong>块状元素</strong>也可以通过代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display:inline</span><br></pre></td></tr></table></figure>

<p>将元素设置为<strong>内联元素</strong>。如下代码就是将<strong>块状元素 div</strong> 转换为<strong>内联元素</strong>，从而使 div 元素具有<strong>内联元素</strong>特点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line"> display:inline;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>内联元素特点：</strong></p>
<blockquote>
<p>1、和其他元素都在一行上；<br>2、元素的高度、宽度及顶部和底部边距<strong>不可</strong>设置；<br>3、元素的宽度就是它包含的文字或图片的宽度，不可改变。</p>
</blockquote>
<h2 id="·-元素分类-–-内联块状元素"><a href="#·-元素分类-–-内联块状元素" class="headerlink" title="· 元素分类 – 内联块状元素"></a>· 元素分类 – 内联块状元素</h2><p><strong>内联块状元素（</strong>inline-block<strong>）</strong>就是同时具备内联元素、块状元素的特点，代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display:inline-block</span><br></pre></td></tr></table></figure>

<p>就是将元素设置为内联块状元素。(css2.1 新增)，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img&gt;、&lt;input&gt;</span><br></pre></td></tr></table></figure>

<p>标签就是这种内联块状标签。</p>
<p><strong>inline-block 元素特点：</strong></p>
<blockquote>
<p>1、和其他元素都在一行上；<br>2、元素的高度、宽度、行高以及顶和底边距都可设置。</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 组件内容分发（slot）</title>
    <url>/2019/11/19/Vue-%E7%BB%84%E4%BB%B6%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%EF%BC%88slot%EF%BC%89/</url>
    <content><![CDATA[<p>在实际项目开发当中，时常会把父组件的内容与子组件自己的模板混合起来使用。而这样的一个过程在 Vue 中被称为<strong>内容分发</strong>。也常常被称为<strong><code>slot</code>（插槽）</strong>。其主要参照了当前 <a href="//github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md">Web Components 规范草案</a>，使用特殊的<code>&lt;slot&gt;</code>元素作为原始内容的插槽。今天主要来学习如何在 Vue 中使用<code>slot</code>的功能。</p><a id="more"></a>
<h2 id="先简单的了解一个概念"><a href="#先简单的了解一个概念" class="headerlink" title="先简单的了解一个概念"></a>先简单的了解一个概念</h2><p>在深入理解 Vue 的<code>slot</code>之前，先来简单的了解一个有关于<code>slot</code>的概念，便于后续的学习和理解。</p>
<p>前面也说过了，Vue 中的<code>slot</code>源于 Web Components 规范草案，也被称之为插槽，是组件的一块 HTML 模板，而这块模板显示不显示，以及怎么显示由父组件来决定。那么，Vue 中一个<code>slot</code>最核心的两个问题就出来了：</p>
<ul>
<li><strong>显示不显示</strong></li>
<li><strong>怎么显示</strong></li>
</ul>
<p>由于<code>slot</code>是一块模板，因此对于任何一个组件，从模板种类的角度来分，共实都可分为<strong>非插槽模板</strong>和<strong>插槽模板</strong>。其中非插槽模板指的是 HTML 模板（也就是 HTML 的一些元素，比如<code>div</code>、<code>span</code>等构成的），其显与否及怎么显示完全由插件自身控制；但插槽模板（也就是<code>slot</code>）是一个空壳子，它显示与否以及怎么显示完全是由<strong>父组件</strong>来控制。不过，<strong>插槽显示的位置由子组件自身决定，<code>slot</code>写在组件<code>template</code>的哪块，父组件传过来的模板将来就显示在哪块</strong>。</p>
<h2 id="Vue-的编译作用域"><a href="#Vue-的编译作用域" class="headerlink" title="Vue 的编译作用域"></a>Vue 的编译作用域</h2><p>简单的了解了<code>slot</code>中的基本概念，从基本概念中可以获知，使用<code>slot</code>会涉及 Vue 的模板，而 Vue 的模板在渲染成 UI 之前是有一个编译过程的，也会存在模板<strong>编译作用域</strong>一说。理解清楚这部分内容，也更有助于我们理解<code>slot</code>，所以花点时间先简单的理解一下 Vue 的编译作用域。</p>
<p>在前面的《<a href="//www.w3cplus.com/vue/vue-instances-and-life-cycles.html">Vue 实例和生命周期</a>》一文中，我们了解了 Vue 的生命周期相关的知识点，此处不再阐述，上张介绍 Vue 生命周期的图：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1711/vue-instances-and-life-cycles-8.png" alt></p>
<p>碰到是否有<code>template</code>选项时，会询问是否要对<code>template</code>进行编译：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1803/vue-slot-1.png" alt></p>
<p>在<code>template</code>编译（渲染成 UI）有一个过程。模板通过编译生成 AST，再由 AST 生成 Vue 的渲染函数，渲染函数结合数据生成 Virtual DOM 树，对 Virtual DOM 进行<code>diff</code>和<code>patch</code>后生成新的 UI。将上图细化一下，也就是<code>template</code>编译的过程如下图所示：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1710/vue-template-9.jpg" alt></p>
<p>在深入一点，如下：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1710/vue-template-10.png" alt></p>
<blockquote>
<p>有关于 Vue 中<code>template</code>的渲染的详细过程，可以阅读《<a href="//www.w3cplus.com/vue/vue-template.html">Vue 的模板</a>》一文。</p>
</blockquote>
<p>简理的理解就是 Vue 中的<code>template</code>编译成浏览器可识的过程会经过不少的过程。言外之意，最终在浏览器中呈现的并不是<code>&lt;template&gt;</code>，而是会解析成标准的 HTML，然后将组件的标签替换为对应的 HTML 片段。用个小示例来举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;myComponent&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;button @click=&quot;show&quot;&gt;Show Message&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">    template: &apos;#myComponent&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message: &apos;我是一个Vue组件!&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        show: function () &#123;</span><br><span class="line">            alert(this.message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Vue 将会通过其自身的编译机制（如前图所示的过程），将<code>&lt;my-component&gt;</code>编译成让浏览器可以识别的 HTML 代码。可以借助浏览器开发者工具一探究竟：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1803/vue-slot-2.png" alt></p>
<p>我的理解是这样的。上面的示例通过<code>new Vue()</code>创建一下人 Vue 的实例，并且将这个实例挂载到<code>div#app</code>的元素下，然后把组件<code>&lt;my-component&gt;</code>编译成 HTML，最终渲染所需要的 UI 效果。继续用张图来描述这个过程，一图胜过千言万语嘛。</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1803/vue-slot-3.png" alt></p>
<p>我们要说的是模板编译的作用域，在 Vue 中，组件是有一个作用域的：<strong>组件模板（<code>&lt;template&gt;</code>）</strong>内的就是组件作用域，而其之外的就不是组件的作用域了，比如上面的示例，<code>my-component</code>组件的作用域就是下面这部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template id=&quot;myComponent&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;button @click=&quot;show&quot;&gt;Show Message&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>组件的模板是在其作用域内编译的，因此组件选项对象中的<code>data</code>也是在组件模板中使用的。如果我们在前面的示例中的 Vue 实例的组件<code>my-component</code>中同时追加一个<code>display</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">    template: &apos;#myComponent&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message: &apos;我是一个Vue组件!&apos;,</span><br><span class="line">            display: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        show: function () &#123;</span><br><span class="line">            alert(this.message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            display: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后在<code>&lt;my-component&gt;</code>中使用指令<code>v-show=&quot;display&quot;</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;my-component v-show=&quot;display&quot;&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>试问，此时<code>display</code>是来源于 Vue 实例，还是<code>my-component</code>组件呢？答案很简单：<strong><code>display</code>来源于 Vue 实例</strong>。也就是说，在 Vue 中组件的作用域是独立的：</p>
<blockquote>
<p><strong>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。</strong></p>
</blockquote>
<p>通俗地讲，在子组件中定义的数据，只能用在子组件的模板。在父组件中定义的数据，只能用在父组件的模板。如果父组件的数据要在子组件中使用，则需要子组件定义<code>props</code>。有关于这方面的内容可以阅读：</p>
<ul>
<li>《<a href="//www.w3cplus.com/vue/component-data-and-props-part1.html">组件数据传递</a>》</li>
<li>《<a href="//www.w3cplus.com/vue/component-data-and-props-part2.html">实现组件数据的双向绑定</a>》</li>
<li>《<a href="//www.w3cplus.com/vue/component-data-and-props-part3.html">不同场景下组件间的数据通讯</a>》</li>
</ul>
<p>简单的了解了 Vue 编译的作用域之后，咱们接着回到我们今天要聊的主题，Vue 的<code>slot</code>。</p>
<h2 id="slot大致用法"><a href="#slot大致用法" class="headerlink" title="slot大致用法"></a><code>slot</code>大致用法</h2><p>先来简单的看一下 Vue 中的<code>slot</code>的使用方法。比如我们有一个类似<code>alert</code>的小组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;alert&gt;&lt;/alert&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;alert&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;alert info&quot;&gt;</span><br><span class="line">        &lt;button class=&quot;close&quot;&gt;×&lt;/button&gt;</span><br><span class="line">        &lt;slot&gt;This is alert box!&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;alert&apos;, &#123;</span><br><span class="line">    template: &apos;#alert&apos;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的代码在<code>alert</code>组件的模板中指定了一个<code>&lt;slot&gt;</code>元素，并且在该元素中放置了一个默认内容 “This is alert box!”。在调用<code>alert</code>组件时，并没有向该组件分发任何内容，这个时候运行的结果如下：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1803/vue-slot-5.png" alt></p>
<p>从上面的效果中可以得知：<strong>如果父组件未向模板中分发内容（插入内容），则显示插槽中默认内容（前提是<code>slot</code>中设置了默认内容）</strong>。</p>
<p>接下来，在上面的示例上，做小小的修改，在<code>&lt;alert&gt;</code>使用的时候，插入你想要的内容（也就是指父组件向模板分发内容）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;alert&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;Hello W3cplus!&lt;/h2&gt;</span><br><span class="line">            &lt;p&gt;欢迎您来到w3cplus.com！&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/alert&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码得到的效果是：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1803/vue-slot-6.png" alt></p>
<p>从代码运行的结果可以得知：<strong>父组件给模板分发了内容，则分发的内容会替换<code>slot</code>标签</strong>。除此之外，假设<strong>模板中未设置插槽，父组件依旧向其分发了内容，但最终任何分发的内容都不会显示</strong>。比如下图所示：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1803/vue-slot-7.png" alt></p>
<p>在介绍编译作用域时，了解到，<strong>父组件的内容是在父组件作用域编译，子组件的内容是在子组件作用域编译</strong>。而 Vue 的<code>slot</code>一般用在父组件向子组件分发内容，该内容的编译作用域名为父组件作用域。</p>
<p>继续拿上面的<code>alert</code>组件来举例。在我们的<code>alert</code>组件中，很多时候有多种样式风格，除了<code>info</code>之外，还有<code>success</code>、<code>danger</code>和<code>warning</code>之类。我们可以在父组件的编译时绑定<code>status</code>状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;alert v-for=&quot;statu in status&quot; :status=statu&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;&#123;&#123; statu &#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;p&gt;欢迎您来到w3cplus.com！&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/alert&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;alert&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;alert&quot; :class=&quot;[alertStatus]&quot; v-show=&quot;isShow&quot;&gt;</span><br><span class="line">        &lt;button class=&quot;close&quot; @click=&quot;close&quot;&gt;×&lt;/button&gt;</span><br><span class="line">        &lt;slot&gt;This is alert box!&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;alert&apos;, &#123;</span><br><span class="line">    template: &apos;#alert&apos;,</span><br><span class="line">    props: [&apos;status&apos;],</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            isShow: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        alertStatus: function () &#123;</span><br><span class="line">            return this.status</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        close: function () &#123;</span><br><span class="line">            this.isShow = !this.isShow</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            status: [&apos;info&apos;, &apos;success&apos;, &apos;danger&apos;, &apos;warning&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最终效果如下：</p>
<h2 id="slot-分类"><a href="#slot-分类" class="headerlink" title="slot 分类"></a>slot 分类</h2><p>在 Vue 中，<code>slot</code>也分多种，从 Vue 的官网中可以获知，其主要分为：<strong>单个插槽</strong>、<strong>具名插槽</strong>和<strong>作用域插槽</strong>三种。接下来我们借助 <a href="//www.w3cplus.com/vue/vue-modal-component.html"><code>modal</code>组件</a>为例，看看 Vue 中的这几种插槽怎么使用。</p>
<p>Web 中常见的<code>modal</code>弹框外形长得大致都如下图这样：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1801/modal-vue-2.png" alt></p>
<h3 id="单个插槽"><a href="#单个插槽" class="headerlink" title="单个插槽"></a>单个插槽</h3><p>在介绍<code>slot</code>大致使用方法的一节中，已经知道了，如果子组件<code>template</code>中没有包含任何一个<code>&lt;slot&gt;</code>时，就算父组件分发再多的内容也将会被<strong>丢弃</strong>。只有子组件模板只要有一个没有属性的<code>slot</code>（因为在模板中可以有多个带属性的<code>slot</code>，后面的内容会介绍），父组件传入的整个内容片段将插入到<code>slot</code>所在的 DOM 位置，并将替换掉<code>slot</code>本身。</p>
<p>最初在<code>&lt;slot&gt;</code>中的任何内容都被视为<strong>备用内容</strong>（也可以在最初的<code>&lt;slot&gt;</code>中不放置任何默认内容）。备用内容在子组件的作用域内编译，并且只有在宿主元素（父组件没有分发任何内容）为空，且没有要插入的内容时才显示备用内容。</p>
<p>如果拿<code>modal</code>来举例，在单个插槽时，整个<code>modal</code>的内容都将需要通过父组件来进行分发。我们可以这样写（可能不太理想，但我们后面会慢慢让她变得更完善）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- modal组件模板 --&gt;</span><br><span class="line">&lt;template id=&quot;modal&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;modal-backdrop&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;modal&quot; @click.stop&gt;</span><br><span class="line">            &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// JavaScript Code</span><br><span class="line">Vue.component(&apos;modal&apos;, &#123;</span><br><span class="line">    template: &apos;#modal&apos;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        close: function (event) &#123;</span><br><span class="line">            this.$emit(&apos;close&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            toggleModal: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        showModal: function () &#123;</span><br><span class="line">            this.toggleModal = true</span><br><span class="line">        &#125;,</span><br><span class="line">        closeModal: function () &#123;</span><br><span class="line">            this.toggleModal = false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在<code>modal</code>组件的<code>template</code>中，只使用了一个<code>&lt;slot&gt;</code>，这个时候在父组件中使用<code>modal</code>组件时，父组件分发的内容就会替换<code>&lt;slot&gt;</code>中的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;modal v-show=&quot;toggleModal&quot; @click=&quot;closeModal&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div class=&quot;modal-header&quot;&gt;</span><br><span class="line">                &lt;div  class=&quot;close rotate&quot; @click=&quot;closeModal&quot;&gt;</span><br><span class="line">                    &lt;i class=&quot;fa-times fa&quot;&gt;&lt;/i&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;h3 class=&quot;modal-title&quot;&gt;Modal Header&lt;/h3&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;modal-body&quot;&gt;</span><br><span class="line">                &lt;h3&gt;Modal Body&lt;/h3&gt;</span><br><span class="line">                &lt;p&gt;Modal body conent...&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;modal-footer&quot;&gt;</span><br><span class="line">                &lt;button class=&quot;btn&quot; @click=&quot;closeModal&quot;&gt;关闭&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/modal&gt;</span><br><span class="line">    &lt;button class=&quot;btn btn-open&quot; @click=&quot;showModal&quot;&gt;Show Modal&lt;/button&gt;</span><br><span class="line">&lt;/div</span><br></pre></td></tr></table></figure>

<p>最终的效果如下：</p>
<p>这样写感觉是不是怪怪的。我也是这么认为的，这只是为了说明单个<code>slot</code>的使用。接下来我们看看具名插槽。</p>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p><code>&lt;slot&gt;</code>可以用一个特殊的属性<code>name</code>来进一步配置父组件如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应<code>slot</code>特性的元素。</p>
<p>仍然可以有一个匿名插槽，它是<strong>默认插槽</strong>，作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。</p>
<p>前面示例写的<code>modal</code>组件使用了一个匿名<code>slot</code>。如果我们使用多个<code>slot</code>时，会让<code>modal</code>组件变得更为灵活。众所周知，对于一个<code>modal</code>组件，其主体结构包括了<code>modal-header</code>、<code>modal-body</code>和<code>modal-footer</code>（当然，很多时候可能不会同时出现，根据需要选择）。那么在定义<code>modal</code>组件的<code>template</code>时，可以使用三个<code>slot</code>，它们的<code>name</code>属性分别命名为<code>header</code>、<code>body</code>和<code>footer</code>。</p>
<p>基于上例，把模板修改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template id=&quot;modal&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;modal-backdrop&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;modal&quot; @click.stop&gt;</span><br><span class="line">            &lt;slot &gt;&lt;/slot&gt;</span><br><span class="line">            &lt;slot &gt;&lt;/slot&gt;</span><br><span class="line">            &lt;slot &gt;&lt;/slot&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>在使用模板的时候：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;modal v-show=&quot;toggleModal&quot; @click=&quot;closeModal&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;modal-header&quot; slot=&quot;header&quot;&gt;</span><br><span class="line">            &lt;div  class=&quot;close rotate&quot; @click=&quot;closeModal&quot;&gt;</span><br><span class="line">            &lt;i class=&quot;fa-times fa&quot;&gt;&lt;/i&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;h3 class=&quot;modal-title&quot;&gt;Modal Header&lt;/h3&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;modal-body&quot; slot=&quot;body&quot;&gt;</span><br><span class="line">            &lt;h3&gt;Modal Body&lt;/h3&gt;</span><br><span class="line">            &lt;p&gt;Modal body conent...&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;modal-footer&quot; slot=&quot;footer&quot;&gt;</span><br><span class="line">            &lt;button class=&quot;btn&quot; @click=&quot;closeModal&quot;&gt;关闭&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/modal&gt;</span><br><span class="line">    &lt;button class=&quot;btn btn-open&quot; @click=&quot;showModal&quot;&gt;Show Modal&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>其他不变，最终的效果如下：</p>
<p>这个时候，你可以根据你的需要，在使用的时候视项目情况去选择，使用具名的插槽。</p>
<blockquote>
<p>在《<a href="//www.w3cplus.com/vue/vue-modal-component.html">使用 Vue 创建 Modal 组件</a>》一文中，也涉及到了<code>slot</code>的内容，现在回过头来看，将会变得更轻松些。</p>
</blockquote>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽是一种特殊类型的插槽，用作一个（能被传递数据的）可重用模板，来代替已经渲染好的元素。</p>
<p>在子组件中，只需将数据传递到插槽，就像你将<code>prop</code>传递给组件一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>在父级中，具有特殊特性 <code>slot-scope</code> 的 <code>&lt;template&gt;</code> 元素必须存在，表示它是作用域插槽的模板。<code>slot-scope</code> 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 <code>prop</code> 对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;child&gt;</span><br><span class="line">        &lt;template slot-scope=&quot;props&quot;&gt;</span><br><span class="line">            &lt;span&gt;hello from parent&lt;/span&gt;</span><br><span class="line">            &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">    &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们渲染上述模板，得到的输出会是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">        &lt;span&gt;hello from parent&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;hello from child&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>在 2.5.0+，<code>slot-scope</code> 能被用在任意元素或组件中而不再局限于 <code>&lt;template&gt;</code></strong>。</p>
</blockquote>
<p>作用域插槽更典型的用例是在列表组件中，允许使用者自定义如何渲染列表的每一项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;my-awesome-list :items=&quot;items&quot;&gt;</span><br><span class="line">    &lt;!-- 作用域插槽也可以是具名的 --&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        slot=&quot;item&quot;</span><br><span class="line">        slot-scope=&quot;props&quot;</span><br><span class="line">        class=&quot;my-fancy-item&quot;&gt;</span><br><span class="line">        &#123;&#123; props.text &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/my-awesome-list&gt;</span><br></pre></td></tr></table></figure>

<p>列表组件的模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;slot</span><br><span class="line">        v-for=&quot;item in items&quot;</span><br><span class="line">        :text=&quot;item.text&quot;&gt;</span><br><span class="line">        &lt;!-- 这里写入备用内容 --&gt;</span><br><span class="line">    &lt;/slot&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p><code>slot-scope</code> 的值实际上是一个可以出现在函数签名参数位置的合法的 JavaScript 表达式。这意味着在受支持的环境 (单文件组件或现代浏览器) 中，您还可以在表达式中使用 ES2015 解构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;child&gt;</span><br><span class="line">    &lt;span slot-scope=&quot;&#123; text &#125;&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/child&gt;</span><br></pre></td></tr></table></figure>

<p>比如下面这个示例：</p>
<p>如果想进一步的了解<code>slot</code>中的作用域插槽，可以阅读《<a href="//www.w3cplus.com/vue/vue-js-scoped-slots.html">Vue 的作用域插槽</a>》一文。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要学习和了解了 Vue 中的插槽<code>&lt;slot&gt;</code>。是一个空壳子，它显示与否以及怎么显示完全是由<strong>父组件</strong>来控制。不过，<strong>插槽显示的位置由子组件自身决定，<code>slot</code>写在组件<code>template</code>的哪块，父组件传过来的模板将来就显示在哪块</strong>。在写一些组件的时候，<code>slot</code>能帮助我们做很多事情，也能让组件可复用性变得更为灵活。</p>
<p><a href="//weibo.com/w3cplus"><img src="https://www.w3cplus.com/sites/default/files/blogs/author/airen.jpg" alt></a></p>
<h3 id="大漠"><a href="#大漠" class="headerlink" title="大漠"></a><a href="//weibo.com/w3cplus">大漠</a></h3><p>常用昵称 “大漠”，W3CPlus 创始人，目前就职于手淘。对 HTML5、CSS3 和 Sass 等前端脚本语言有非常深入的认识和丰富的实践经验，尤其专注对 CSS3 的研究，是国内最早研究和使用 CSS3 技术的一批人。CSS3、Sass 和 Drupal 中国布道者。2014 年出版《<a href="//www.w3cplus.com/book-comment.html">图解 CSS3：核心技术与案例实战</a>》。</p>
<p>如需转载，烦请注明出处：<a href="//www.w3cplus.com/vue/vue-slot.html">https://www.w3cplus.com/vue/vue-slot.html</a><a href="https://www.febshoes.com/category/556" target="_blank" rel="noopener">Air Jordan 89 Shoes</a></p>
<p>如需转载，烦请注明出处：<a href="https://www.w3cplus.com/vue/vue-slot.html" target="_blank" rel="noopener">https://www.w3cplus.com/vue/vue-slot.html</a></p>
<blockquote>
<p><strong>如果文章中有不对之处，烦请各位大神拍正。如果你觉得这篇文章对你有所帮助，<a href="//www.zhi12.com/paycenter/reward/widget?entity=user&id=5491">打个赏，让我有更大的动力去创作</a>。(^_^)。看完了？还不过瘾？点击<a href="//www.zhi12.com/ask/5491/widget">向作者提问！</a></strong></p>
</blockquote>
<p>赏杯咖啡，鼓励他创作更多优质内容！ <a href="//www.zhi12.com/paycenter/reward/widget?entity=user&id=5491"><img src="https://www.w3cplus.com/sites/default/files/blogs/2018/1807/shang1.png" alt></a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>slot</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域资源共享 CORS 详解</title>
    <url>/2019/11/19/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB-CORS-%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>CORS 是一个 W3C 标准，全称是 “跨域资源共享”（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出 <a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a>请求，从而克服了 AJAX 只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">同源</a>使用的限制。</p>
<a id="more"></a>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><hr>
<p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。</p>
<p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。</p>
<h2 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h2><hr>
<p>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<blockquote>
<p>（1) 请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP 的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h2 id="三、简单请求"><a href="#三、简单请求" class="headerlink" title="三、简单请求"></a>三、简单请求</h2><hr>
<h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p>
<p>下面是一个例子，浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<h4 id="（1）Access-Control-Allow-Origin"><a href="#（1）Access-Control-Allow-Origin" class="headerlink" title="（1）Access-Control-Allow-Origin"></a><strong>（1）Access-Control-Allow-Origin</strong></h4><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<h4 id="（2）Access-Control-Allow-Credentials"><a href="#（2）Access-Control-Allow-Credentials" class="headerlink" title="（2）Access-Control-Allow-Credentials"></a><strong>（2）Access-Control-Allow-Credentials</strong></h4><p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送 Cookie，删除该字段即可。</p>
<h4 id="（3）Access-Control-Expose-Headers"><a href="#（3）Access-Control-Expose-Headers" class="headerlink" title="（3）Access-Control-Expose-Headers"></a><strong>（3）Access-Control-Expose-Headers</strong></h4><p>该字段可选。CORS 请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到 6 个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>
<h3 id="3-2-withCredentials-属性"><a href="#3-2-withCredentials-属性" class="headerlink" title="3.2 withCredentials 属性"></a>3.2 withCredentials 属性</h3><p>上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
</blockquote>
<p>另一方面，开发者必须在 AJAX 请求中打开<code>withCredentials</code>属性。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。</p>
<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.withCredentials = false;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>需要注意的是，如果要发送 Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的 Cookie。</p>
<h2 id="四、非简单请求"><a href="#四、非简单请求" class="headerlink" title="四、非简单请求"></a>四、非简单请求</h2><hr>
<h3 id="4-1-预检请求"><a href="#4-1-预检请求" class="headerlink" title="4.1 预检请求"></a>4.1 预检请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为 “预检” 请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<p>下面是一段浏览器的 JavaScript 脚本。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var url = &apos;http://api.alice.com/cors&apos;;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;PUT&apos;, url, true);</span><br><span class="line">xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，HTTP 请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个 “预检” 请求，要求服务器确认可以这样请求。下面是这个 “预检” 请求的 HTTP 头信息。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>“预检” 请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，”预检” 请求的头信息包括两个特殊字段。</p>
<h4 id="（1）Access-Control-Request-Method"><a href="#（1）Access-Control-Request-Method" class="headerlink" title="（1）Access-Control-Request-Method"></a><strong>（1）Access-Control-Request-Method</strong></h4><p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是<code>PUT</code>。</p>
<h4 id="（2）Access-Control-Request-Headers"><a href="#（2）Access-Control-Request-Headers" class="headerlink" title="（2）Access-Control-Request-Headers"></a><strong>（2）Access-Control-Request-Headers</strong></h4><p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h3 id="4-2-预检请求的回应"><a href="#4-2-预检请求的回应" class="headerlink" title="4.2 预检请求的回应"></a>4.2 预检请求的回应</h3><p>服务器收到 “预检” 请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的 HTTP 回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果浏览器否定了 “预检” 请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>服务器回应的其他 CORS 相关字段如下。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="（1）Access-Control-Allow-Methods"><a href="#（1）Access-Control-Allow-Methods" class="headerlink" title="（1）Access-Control-Allow-Methods"></a><strong>（1）Access-Control-Allow-Methods</strong></h4><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次 “预检” 请求。</p>
<h4 id="（2）Access-Control-Allow-Headers"><a href="#（2）Access-Control-Allow-Headers" class="headerlink" title="（2）Access-Control-Allow-Headers"></a><strong>（2）Access-Control-Allow-Headers</strong></h4><p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在 “预检” 中请求的字段。</p>
<h4 id="（3）Access-Control-Allow-Credentials"><a href="#（3）Access-Control-Allow-Credentials" class="headerlink" title="（3）Access-Control-Allow-Credentials"></a><strong>（3）Access-Control-Allow-Credentials</strong></h4><p>该字段与简单请求时的含义相同。</p>
<h4 id="（4）Access-Control-Max-Age"><a href="#（4）Access-Control-Max-Age" class="headerlink" title="（4）Access-Control-Max-Age"></a><strong>（4）Access-Control-Max-Age</strong></h4><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。</p>
<h3 id="4-3-浏览器的正常请求和回应"><a href="#4-3-浏览器的正常请求和回应" class="headerlink" title="4.3 浏览器的正常请求和回应"></a>4.3 浏览器的正常请求和回应</h3><p>一旦服务器通过了 “预检” 请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是 “预检” 请求之后，浏览器的正常 CORS 请求。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h2 id="五、与-JSONP-的比较"><a href="#五、与-JSONP-的比较" class="headerlink" title="五、与 JSONP 的比较"></a>五、与 JSONP 的比较</h2><hr>
<p>CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。</p>
<p>JSONP 只支持<code>GET</code>请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存头 Cache-Control 的含义和使用</title>
    <url>/2019/11/18/%E7%BC%93%E5%AD%98%E5%A4%B4-Cache-Control-%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><blockquote>
<p>以下这些头只是限制性的，声明性的作用，没有强制约束力。只是为代理服务器设置了这些头，要求按照规范去做，但是完全可以不按照这个规范做。</p>
</blockquote>
<a id="more"></a>

<ul>
<li><h5 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h5><ul>
<li>public<br>在 http 请求返回的过程当中，在 Cache-Control 设置了 public 值，代表这个 http 请求返回的内容所经过的任何路径当中，包括一些中间的 http 代理服务器以及我们发出请求的客户端浏览器，都可以进行对返回内容的缓存操作：就是把这份数据存在本地，下次直接读这个缓存，不需要到返回这个内容的服务器上面重新进行操作返回内容。可缓存性是指哪些地方可以执行这些缓存。</li>
<li>private<br>只要发起请求的浏览器才可以缓存</li>
<li>no-cache<br>任何节点都不可以缓存。可以在本地服务器缓存，每次发起请求都需要去服务器验证，如果服务器说可以使用缓存，才能使用缓存。也就是说需要经过服务器验证的。</li>
</ul>
</li>
<li><h5 id="到期"><a href="#到期" class="headerlink" title="到期"></a>到期</h5><ul>
<li>max-age=<seconds><br>缓存有效期</seconds></li>
<li>s-maxage=<seconds><br>代替上面的 max-age，但是只有在代理服务器里面才会生效</seconds></li>
<li>max-stale=<seconds><br>max-stale：浏览器用不到，浏览器并不会主动去设置这个头，只有在发起端设置是有用的，服务端返回的内容中设置没有用。发起请求方，主动带的头，在 max-age 过期之后，如果我们返回的资源中有这个 max-stale 设置，还可以使用过期的缓存，而不需要去服务器请求新的内容。</seconds></li>
</ul>
</li>
<li><h5 id="重新验证"><a href="#重新验证" class="headerlink" title="重新验证"></a>重新验证</h5><ul>
<li>must-revalidate<br>设置了 max-age，如果缓存已经过期了，必须去原服务端发送这个请求，重新获取数据，来验证内容是否真的过期了，而不能直接使用本地缓存。</li>
<li>proxy-revalidate<br>用在指定缓存服务器，在过期的时候必须去原服务器重新请求一遍，而不能直接使用本地缓存。</li>
</ul>
</li>
<li><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul>
<li>no-store<br>本地和代理服务器不可以存储这个缓存，永远要去服务器拿新的 body 的内容。</li>
<li>no-transform<br>不允许代理服务器不要改动返回的内容。  </li>
</ul>
</li>
</ul>
<h3 id="浏览器中用到的"><a href="#浏览器中用到的" class="headerlink" title="浏览器中用到的:"></a>浏览器中用到的:</h3><ul>
<li><h5 id="可缓存性-1"><a href="#可缓存性-1" class="headerlink" title="可缓存性"></a>可缓存性</h5><ul>
<li>public</li>
<li>private</li>
<li>no-cahe</li>
</ul>
</li>
<li><h5 id="到期-1"><a href="#到期-1" class="headerlink" title="到期"></a>到期</h5><ul>
<li>max-age=<seconds></seconds></li>
<li>s-maxage=<seconds></seconds></li>
<li>max-stale=<seconds></seconds></li>
</ul>
</li>
<li><h5 id="重新验证-1"><a href="#重新验证-1" class="headerlink" title="重新验证"></a>重新验证</h5><ul>
<li><p>must-revalidate</p>
</li>
<li><p>设置请求文件缓存时间<br><code>&#39;Cache-Control&#39;: &#39;max-age=20&#39;</code></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.createServer(function (request, response) &#123;</span><br><span class="line">  console.log(&apos;request come&apos;, request.url)</span><br><span class="line"></span><br><span class="line">  if (request.url === &apos;/&apos;) &#123;</span><br><span class="line">    const html = fs.readFileSync(&apos;test.html&apos;, &apos;utf8&apos;)</span><br><span class="line">    response.writeHead(200, &#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;text/html&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    response.end(html)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (request.url === &apos;/script.js&apos;) &#123;</span><br><span class="line">    response.writeHead(200, &#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;text/javascript&apos;,</span><br><span class="line">      // 设置到期时间</span><br><span class="line">      &apos;Cache-Control&apos;: &apos;max-age=20&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    response.end(&apos;console.log(&quot;script loaded&quot;)&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(8888)</span><br></pre></td></tr></table></figure>

<p>问题 ： 这时如果改变了服务器返回的结果，刷新，发现返回的还是之前的结果，并不是最新的。这是因为服务器端更新了之后，客户端还是请求的缓存的资源，这样想要更新一个应用的时候，客户端根本触及不到了，一般 max-ag 可能会设置一年。<br>解决：在构建流程的时候，把打包完成的 JS 文件名根据内容的 hash 结果，加上一串 hash 码，这串 hash 码是因为根据打包完成的 js 以及其他静态资源的文件内容进行性的 hash 计算，所以如果这些静态文件内容没有变，hash 码就不变，反应到 web 页面上就是 url 没有变，那么就可以使用静态缓存；而如果你的内容有变，hash 码就会变化，嵌入在 html 的 url 路径就有变化，有了变化之后发起的请求就是一个新的静态资源请求而不是之前缓存的请求。这样就可以达到缓存的目的。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Java文件读写</title>
    <url>/2019/11/18/Java%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<h2 id="Java文件读写"><a href="#Java文件读写" class="headerlink" title="Java文件读写"></a>Java文件读写</h2><a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/13863123-3b31b9635a45a269.jpg" alt> <img src="http://upload-images.jianshu.io/upload_images/13863123-e669017cd996500b.jpg" alt></p>
<h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a><strong>IO 流</strong></h3><ol>
<li>IO 流：用于处理设备上的数据。</li>
</ol>
<p>设备：硬盘，内存，键盘录入。</p>
<ol start="2">
<li>IO 有具体的分类：</li>
</ol>
<p>（1）根据处理的数据类型不同：字节流和字符流。</p>
<p>（2）根据流向不同：输入流和输出流。</p>
<p>字符流的由来：</p>
<p>因为文件编码的不同，而有了对字符进行高效操作的字符流对象。</p>
<p>原理：其实就是基于字节流读取字节时，去查了指定的码表。</p>
<p>字节流和字符流的区别：</p>
<p>（1）字节流读取的时候，读到一个字节就返回一个字节。</p>
<p>字符流使用了字节流读到一个或多个字节（中文对应的字节数是两个，在 UTF-8 码表中是 3 个字节）时，先去查指定的编码表，将查到的字符返回。</p>
<p><strong>（2）字节流可以处理所有类型数据，如 MP3，图片，avi。而字符流只能处理字符数据。</strong></p>
<p><strong>结论：只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都要用字节流。</strong></p>
<p>IO 的体系，所具备的基本功能就有两个：读和写。</p>
<ol>
<li><p>字节流：InputStream(读)，OutputStream（写）。</p>
</li>
<li><p>字符流：Reader（读），Writer（写）。</p>
</li>
</ol>
<h3 id="一-字符流"><a href="#一-字符流" class="headerlink" title="一. 字符流:"></a><strong>一. 字符流:</strong></h3><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p>|–InputStreamReader  </p>
<p>　　 |–FileReader: 专门用于处理文件的字符读取流对象。  </p>
<h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p> |–OutputStreamWriter  </p>
<p>　　 |–FileWriter: 专门用于处理文件的字符写入流对象</p>
<h4 id="Reader-中的常见的方法："><a href="#Reader-中的常见的方法：" class="headerlink" title="Reader 中的常见的方法："></a>Reader 中的常见的方法：</h4><ol>
<li>int read()：  </li>
</ol>
<p>　　 读取一个字符。返回的是读到的那个字符。如果读到流的末尾，返回 - 1.  </p>
<p>*<em>2. int read(char[])：    *</em></p>
<p>**　　将读到的字符存入指定的数组中，返回的是读到的字符个数，也就是往数组里装的元素的个数。如果读到流的末尾，返回 - 1.  **</p>
<ol start="3">
<li>close():    </li>
</ol>
<p>　　读取字符其实用的是 window 系统的功能，就希望使用完毕后，进行资源的释放。</p>
<h4 id="Writer-中的常见的方法："><a href="#Writer-中的常见的方法：" class="headerlink" title="Writer 中的常见的方法："></a>Writer 中的常见的方法：</h4><p>1，write(ch): 将一个字符写入到流中。  </p>
<p>2，write(char[]): 将一个字符数组写入到流中。</p>
<p>3，write(String): 将一个字符串写入到流中。  </p>
<p>4，flush(): 刷新流，将流中的数据刷新到目的地中，流还存在。  </p>
<p>5，close(): 关闭资源：在关闭前会先调用 flush()，刷新流中的数据去目的地。然流关闭。</p>
<h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter:"></a>FileWriter:</h4><p>该类没有特有的方法。只有自己的构造函数。  </p>
<p>该类特点在于，  </p>
<p>1，用于处理文本文件。  </p>
<p>2，该类中有默认的编码表，  </p>
<p>3，该类中有临时缓冲。</p>
<p>构造函数：在写入流对象初始化时，必须要有一个存储数据的目的地。</p>
<p>  FileWriter(String filename):   该构造函数做了什么事情呢？  </p>
<p>1，调用系统资源。  </p>
<p>2，在指定位置，创建一个文件。  </p>
<p> 注意：如果该文件已存在，将会被覆盖。  </p>
<p>FileWriter(String filename,boolean append):  </p>
<p> 　　该构造函数：当传入的 boolean 类型值为 true 时，会在指定文件末尾处进行数据的续写。</p>
<h4 id="FileReader："><a href="#FileReader：" class="headerlink" title="FileReader："></a>FileReader：</h4><p>1，用于读取文本文件的流对象。  </p>
<p>2，用于关联文本文件。</p>
<p> 构造函数：在读取流对象初始化的时候，必须要指定一个被读取的文件。    </p>
<p>如果该文件不存在会发生 FileNotFoundException.  </p>
<h4 id="FileReader-String-filename"><a href="#FileReader-String-filename" class="headerlink" title="FileReader(String filename);"></a>FileReader(String filename);</h4><p>对于读取或者写入流对象的构造函数，以及读写方法，还有刷新关闭功能都会抛出 IOException 或其子类。</p>
<p>所以都要进行处理，或者 throws 抛出，或者 try、catch 处理。</p>
<h4 id="另一个小细节："><a href="#另一个小细节：" class="headerlink" title="*另一个小细节：  *"></a>*<em>另一个小细节：  *</em></h4><p><strong>当指定绝对路径时，定义目录分隔符有两种方式：</strong></p>
<p><strong>1，反斜线 但是一定要写两个。\  new FileWriter(“c:\demo.txt”);</strong></p>
<p><strong>2，斜线  /  写一个即可。 new FileWriter(“c:/demo.txt”);</strong></p>
<h4 id="字符流的缓冲区："><a href="#字符流的缓冲区：" class="headerlink" title="字符流的缓冲区："></a><strong>字符流的缓冲区：</strong></h4><p>缓冲区的出现提高了对流的操作效率。</p>
<p>原理：其实就是将数组进行封装。</p>
<p>对应的对象：</p>
<p>BufferedWriter：</p>
<p>　　特有方法：</p>
<p><strong>newLine（）：跨平台的换行符。</strong></p>
<p>BufferedReader：</p>
<p>　　特有方法：</p>
<p><strong>readLine（）：一次读一行，到行标记时，将行标记之前的字符数据作为字符串返回。当读到末尾时，返回 null。</strong></p>
<p>使用缓冲区对象时，要明确，缓冲的存在是为了增强流的功能而存在，所以在简历缓冲区对象时，要现有流对象存在。</p>
<p>其实缓冲内部就是在使用流对象的方法，只不过加入了数组对数据进行了临时存储，为了提高操作数据的效率。</p>
<p>代码上的体现:</p>
<p><strong>写入缓冲区对象：</strong></p>
<p>// 建立缓冲区对象必须把流对象作为参数传递给缓冲区的构造函数。</p>
<p>BufferedWriter bw=new BufferedWriter（new FileWriter（“abc.txt”））；</p>
<p>bw.write(“abce”);// 将数据写入到了缓冲区。</p>
<p>bw.flush();// 对缓冲区的数据进行刷新。将数据刷到目的地中。</p>
<p>bw.close();// 关闭缓冲区，其实关闭的是被包装在内部的流对象。</p>
<h3 id="二-字节流"><a href="#二-字节流" class="headerlink" title="二. 字节流:"></a><strong>二. 字节流:</strong></h3><p>抽象基类: InputStream，OutputStream。</p>
<p>字节流可以操作任何数据。</p>
<p>注意：字符流使用的数组是字符数组，char[] chs ；</p>
<p>　　　字节流使用的数组是字节数组，byte[] bt ；</p>
<p>FileOutputStream fos=new FileOutputStream(“a.txt”)；</p>
<p>fos.write(“abcde”); // 直接将数据写入到了目的地。</p>
<p>fos.close();// 只关闭资源。</p>
<p>FileInputSteam fls=new FileInputStream(“a.txt”);</p>
<p>//fis.available();// 获取关联的文件字节数。如果文件体积不大，可以这样操作。</p>
<p>byte[]buf=new byte[fis.available()];// 创建一个刚刚好的缓冲区。// 但是这有一个弊端，就是文件过大，大小超出 Jvm 的内容空间时，会内存溢出。</p>
<p>fis.read(buf);</p>
<p>System.out.println(new String(buf));</p>
<p>例子:</p>
<p>　　需求: copy 一个图片。</p>
<p>BufferedInputStream bufis=new BufferedInputStream(new FileInputStream(“1.jpg”));</p>
<p>BufferedOutputStream bufos=new BufferedOutputStream(new FileOutputStream(“2.jpg”));</p>
<p>int by=0;</p>
<p>while(by=bufis.read()!=-1){</p>
<p>　　bufos.write(by);</p>
<p>　　bufos.newLine();</p>
<p>}</p>
<p>bufis.close();</p>
<p>bufos.close();</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结:"></a><strong>小结:</strong></h3><p>目前学习的流对象:</p>
<p>字符流: FileReader  FileWriter  BuffereedReader  BufferedWriter</p>
<p>字节流: FileInputStream  FileOutputStream   BufferedInputStream  BufferedOutputStream</p>
<p>补充：</p>
<ol>
<li>字节流的 read（）方法读取的是一个字节。为什么返回的不是 byte 类型，而是 int 类型呢？</li>
</ol>
<p>因为 read 方法读到末尾时返回的是 - 1，而在所操作的数据中很容易出现连续多个 1 的情况，而连续读到 8 个 1，就是 - 1，导致读取会提前停止。所以将读到的一个字节提升为一个 int 类型的数值，但是只保留原字节，并在剩余二进制位补 0。</p>
<p>具体操作是：byte&amp;255 or byte&amp;0xff</p>
<ol start="2">
<li>对于 write 方法，可以一次写入一个字节，但接收的是一个 int 类型数值。只写入该 int 类型的数值的最低一个字节（8 位）。</li>
</ol>
<p>简单说：<strong>read 方法对读到的数据进行提升，write 对操作的数据进行转换。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>File</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>DataURL, Blob, File, Image 之间的关系与转换</title>
    <url>/2019/11/18/DataURL-Blob-File-Image-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="使用前景："><a href="#使用前景：" class="headerlink" title="使用前景："></a>使用前景：</h4><p><strong><em>移动端上传拍照图片太大，使用 canvas 压缩后 base64=&gt;blob 二进制表单文件 =&gt;ajax-POST 上传</em></strong> <a id="more"></a><img src="https://oscimg.oschina.net/oscnet/45bb5cc130ba93fa7d2365fb81304c75f9a.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// canvas转dataURL：canvas对象、转换格式、图像品质</span><br><span class="line">function canvasToDataURL(canvas, format, quality) &#123;</span><br><span class="line">    return canvas.toDataURL(format||&apos;image/jpeg&apos;, quality||1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// DataURL转canvas</span><br><span class="line">function dataURLToCanvas(dataurl, cb)&#123;</span><br><span class="line">    var canvas = document.createElement(&apos;CANVAS&apos;);</span><br><span class="line">    var ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.onload = function()&#123;</span><br><span class="line">        canvas.width = img.width;</span><br><span class="line">        canvas.height = img.height;</span><br><span class="line">        ctx.drawImage(img, 0, 0);</span><br><span class="line">        cb(canvas);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = dataurl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// image转canvas：图片地址</span><br><span class="line">function imageToCanvas(src, cb)&#123;</span><br><span class="line">    var canvas = document.createElement(&apos;CANVAS&apos;);</span><br><span class="line">    var ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.src = src;</span><br><span class="line">    img.onload = function ()&#123;</span><br><span class="line">        canvas.width = img.width;</span><br><span class="line">        canvas.height = img.height;</span><br><span class="line">        ctx.drawImage(img, 0, 0);</span><br><span class="line">        cb(canvas);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// canvas转image</span><br><span class="line">    function canvasToImage(canvas)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">        img.src = canvas.toDataURL(&apos;image/jpeg&apos;, 1.0);</span><br><span class="line">        return img;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// File/Blob对象转DataURL</span><br><span class="line">    function fileOrBlobToDataURL(obj, cb)&#123;</span><br><span class="line">        var a = new FileReader();</span><br><span class="line">        a.readAsDataURL(obj);</span><br><span class="line">        a.onload = function (e)&#123;</span><br><span class="line">            cb(e.target.result);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// DataURL转Blob对象</span><br><span class="line">    function dataURLToBlob(dataurl)&#123;</span><br><span class="line">        var arr = dataurl.split(&apos;,&apos;);</span><br><span class="line">        var mime = arr[0].match(/:(.*?);/)[1];</span><br><span class="line">        var bstr = atob(arr[1]);</span><br><span class="line">        var n = bstr.length;</span><br><span class="line">        var u8arr = new Uint8Array(n);</span><br><span class="line">        while(n--)&#123;</span><br><span class="line">            u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Blob([u8arr], &#123;type:mime&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Blob转image</span><br><span class="line">    function blobToImage(blob, cb)&#123;</span><br><span class="line">        fileOrBlobToDataURL(blob, function (dataurl)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">            img.src = dataurl;</span><br><span class="line">            cb(img);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// image转Blob</span><br><span class="line">    function imageToBlob(src, cb)&#123;</span><br><span class="line">        imageToCanvas(src, function (canvas)&#123;</span><br><span class="line">            cb(dataURLToBlob(canvasToDataURL(canvas)));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Blob转canvas</span><br><span class="line">    function BlobToCanvas(blob, cb)&#123;</span><br><span class="line">        fileOrBlobToDataURL(blob, function (dataurl)&#123;</span><br><span class="line">            dataURLToCanvas(dataurl, cb);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// canvas转Blob</span><br><span class="line">function canvasToBlob(canvas, cb)&#123;</span><br><span class="line">	cb(dataURLToBlob(canvasToDataURL(canvas)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// image转dataURL</span><br><span class="line">function imageToDataURL(src, cb)&#123;</span><br><span class="line">	imageToCanvas(src, function (canvas)&#123;</span><br><span class="line">		cb(canvasToDataURL(canvas));</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// dataURL转image，这个不需要转，直接给了src就能用</span><br><span class="line">function dataURLToImage(dataurl)&#123;</span><br><span class="line">	var img = new Image();</span><br><span class="line">	img.src = d;</span><br><span class="line">	return img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Blob</tag>
        <tag>File</tag>
      </tags>
  </entry>
</search>
