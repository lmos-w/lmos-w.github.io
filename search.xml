<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>缓存头 Cache-Control 的含义和使用</title>
    <url>/2019/11/18/%E7%BC%93%E5%AD%98%E5%A4%B4-Cache-Control-%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><blockquote>
<p>以下这些头只是限制性的，声明性的作用，没有强制约束力。只是为代理服务器设置了这些头，要求按照规范去做，但是完全可以不按照这个规范做。</p>
</blockquote>
<a id="more"></a>
<h5 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h5><ul>
<li>public<br>在 http 请求返回的过程当中，在 Cache-Control 设置了 public 值，代表这个 http 请求返回的内容所经过的任何路径当中，包括一些中间的 http 代理服务器以及我们发出请求的客户端浏览器，都可以进行对返回内容的缓存操作：就是把这份数据存在本地，下次直接读这个缓存，不需要到返回这个内容的服务器上面重新进行操作返回内容。可缓存性是指哪些地方可以执行这些缓存。</li>
<li>private<br>只要发起请求的浏览器才可以缓存</li>
<li>no-cache<br>任何节点都不可以缓存。可以在本地服务器缓存，每次发起请求都需要去服务器验证，如果服务器说可以使用缓存，才能使用缓存。也就是说需要经过服务器验证的。</li>
</ul>
<h5 id="到期"><a href="#到期" class="headerlink" title="到期"></a>到期</h5><ul>
<li>max-age=<seconds><br>缓存有效期</li>
<li>s-maxage=<seconds><br>代替上面的 max-age，但是只有在代理服务器里面才会生效</li>
<li>max-stale=<seconds><br>max-stale：浏览器用不到，浏览器并不会主动去设置这个头，只有在发起端设置是有用的，服务端返回的内容中设置没有用。发起请求方，主动带的头，在 max-age 过期之后，如果我们返回的资源中有这个 max-stale 设置，还可以使用过期的缓存，而不需要去服务器请求新的内容。</li>
</ul>
<h5 id="重新验证"><a href="#重新验证" class="headerlink" title="重新验证"></a>重新验证</h5><ul>
<li>must-revalidate<br>设置了 max-age，如果缓存已经过期了，必须去原服务端发送这个请求，重新获取数据，来验证内容是否真的过期了，而不能直接使用本地缓存。</li>
<li>proxy-revalidate<br>用在指定缓存服务器，在过期的时候必须去原服务器重新请求一遍，而不能直接使用本地缓存。</li>
</ul>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul>
<li>no-store<br>本地和代理服务器不可以存储这个缓存，永远要去服务器拿新的 body 的内容。</li>
<li>no-transform<br>不允许代理服务器不要改动返回的内容</li>
</ul>
<hr>
<h3 id="浏览器中用到的"><a href="#浏览器中用到的" class="headerlink" title="浏览器中用到的:"></a>浏览器中用到的:</h3><h5 id="可缓存性-1"><a href="#可缓存性-1" class="headerlink" title="可缓存性"></a>可缓存性</h5><ul>
<li>public</li>
<li>private</li>
<li>no-cahe</li>
</ul>
<h5 id="到期-1"><a href="#到期-1" class="headerlink" title="到期"></a>到期</h5><ul>
<li>max-age=<seconds></li>
<li>s-maxage=<seconds></li>
<li>max-stale=<seconds></li>
</ul>
<h5 id="重新验证-1"><a href="#重新验证-1" class="headerlink" title="重新验证"></a>重新验证</h5><ul>
<li><p>must-revalidate</p>
</li>
<li><p>设置请求文件缓存时间<br><code>&#39;Cache-Control&#39;: &#39;max-age=20&#39;</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.createServer(function (request, response) &#123;</span><br><span class="line">  console.log(&apos;request come&apos;, request.url)</span><br><span class="line"></span><br><span class="line">  if (request.url === &apos;/&apos;) &#123;</span><br><span class="line">    const html = fs.readFileSync(&apos;test.html&apos;, &apos;utf8&apos;)</span><br><span class="line">    response.writeHead(200, &#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;text/html&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    response.end(html)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (request.url === &apos;/script.js&apos;) &#123;</span><br><span class="line">    response.writeHead(200, &#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;text/javascript&apos;,</span><br><span class="line">      // 设置到期时间</span><br><span class="line">      &apos;Cache-Control&apos;: &apos;max-age=20&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    response.end(&apos;console.log(&quot;script loaded&quot;)&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(8888)</span><br></pre></td></tr></table></figure>

<p>问题 ： 这时如果改变了服务器返回的结果，刷新，发现返回的还是之前的结果，并不是最新的。这是因为服务器端更新了之后，客户端还是请求的缓存的资源，这样想要更新一个应用的时候，客户端根本触及不到了，一般 max-ag 可能会设置一年。<br>解决：在构建流程的时候，把打包完成的 JS 文件名根据内容的 hash 结果，加上一串 hash 码，这串 hash 码是因为根据打包完成的 js 以及其他静态资源的文件内容进行性的 hash 计算，所以如果这些静态文件内容没有变，hash 码就不变，反应到 web 页面上就是 url 没有变，那么就可以使用静态缓存；而如果你的内容有变，hash 码就会变化，嵌入在 html 的 url 路径就有变化，有了变化之后发起的请求就是一个新的静态资源请求而不是之前缓存的请求。这样就可以达到缓存的目的。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Java文件读写</title>
    <url>/2019/11/18/Java%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<h2 id="Java文件读写"><a href="#Java文件读写" class="headerlink" title="Java文件读写"></a>Java文件读写</h2><a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/13863123-3b31b9635a45a269.jpg" alt=""> <img src="http://upload-images.jianshu.io/upload_images/13863123-e669017cd996500b.jpg" alt=""></p>
<h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a><strong>IO 流</strong></h3><ol>
<li>IO 流：用于处理设备上的数据。</li>
</ol>
<p>设备：硬盘，内存，键盘录入。</p>
<ol start="2">
<li>IO 有具体的分类：</li>
</ol>
<p>（1）根据处理的数据类型不同：字节流和字符流。</p>
<p>（2）根据流向不同：输入流和输出流。</p>
<p>字符流的由来：</p>
<p>因为文件编码的不同，而有了对字符进行高效操作的字符流对象。</p>
<p>原理：其实就是基于字节流读取字节时，去查了指定的码表。</p>
<p>字节流和字符流的区别：</p>
<p>（1）字节流读取的时候，读到一个字节就返回一个字节。</p>
<p>字符流使用了字节流读到一个或多个字节（中文对应的字节数是两个，在 UTF-8 码表中是 3 个字节）时，先去查指定的编码表，将查到的字符返回。</p>
<p><strong>（2）字节流可以处理所有类型数据，如 MP3，图片，avi。而字符流只能处理字符数据。</strong></p>
<p><strong>结论：只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都要用字节流。</strong></p>
<p>IO 的体系，所具备的基本功能就有两个：读和写。</p>
<ol>
<li><p>字节流：InputStream(读)，OutputStream（写）。</p>
</li>
<li><p>字符流：Reader（读），Writer（写）。</p>
</li>
</ol>
<h3 id="一-字符流"><a href="#一-字符流" class="headerlink" title="一. 字符流:"></a><strong>一. 字符流:</strong></h3><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p>|–InputStreamReader  </p>
<p>　　 |–FileReader: 专门用于处理文件的字符读取流对象。  </p>
<h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p> |–OutputStreamWriter  </p>
<p>　　 |–FileWriter: 专门用于处理文件的字符写入流对象</p>
<h4 id="Reader-中的常见的方法："><a href="#Reader-中的常见的方法：" class="headerlink" title="Reader 中的常见的方法："></a>Reader 中的常见的方法：</h4><ol>
<li>int read()：  </li>
</ol>
<p>　　 读取一个字符。返回的是读到的那个字符。如果读到流的末尾，返回 - 1.  </p>
<p>*<em>2. int read(char[])：    *</em></p>
<p>**　　将读到的字符存入指定的数组中，返回的是读到的字符个数，也就是往数组里装的元素的个数。如果读到流的末尾，返回 - 1.  **</p>
<ol start="3">
<li>close():    </li>
</ol>
<p>　　读取字符其实用的是 window 系统的功能，就希望使用完毕后，进行资源的释放。</p>
<h4 id="Writer-中的常见的方法："><a href="#Writer-中的常见的方法：" class="headerlink" title="Writer 中的常见的方法："></a>Writer 中的常见的方法：</h4><p>1，write(ch): 将一个字符写入到流中。  </p>
<p>2，write(char[]): 将一个字符数组写入到流中。</p>
<p>3，write(String): 将一个字符串写入到流中。  </p>
<p>4，flush(): 刷新流，将流中的数据刷新到目的地中，流还存在。  </p>
<p>5，close(): 关闭资源：在关闭前会先调用 flush()，刷新流中的数据去目的地。然流关闭。</p>
<h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter:"></a>FileWriter:</h4><p>该类没有特有的方法。只有自己的构造函数。  </p>
<p>该类特点在于，  </p>
<p>1，用于处理文本文件。  </p>
<p>2，该类中有默认的编码表，  </p>
<p>3，该类中有临时缓冲。</p>
<p>构造函数：在写入流对象初始化时，必须要有一个存储数据的目的地。</p>
<p>  FileWriter(String filename):   该构造函数做了什么事情呢？  </p>
<p>1，调用系统资源。  </p>
<p>2，在指定位置，创建一个文件。  </p>
<p> 注意：如果该文件已存在，将会被覆盖。  </p>
<p>FileWriter(String filename,boolean append):  </p>
<p> 　　该构造函数：当传入的 boolean 类型值为 true 时，会在指定文件末尾处进行数据的续写。</p>
<h4 id="FileReader："><a href="#FileReader：" class="headerlink" title="FileReader："></a>FileReader：</h4><p>1，用于读取文本文件的流对象。  </p>
<p>2，用于关联文本文件。</p>
<p> 构造函数：在读取流对象初始化的时候，必须要指定一个被读取的文件。    </p>
<p>如果该文件不存在会发生 FileNotFoundException.  </p>
<h4 id="FileReader-String-filename"><a href="#FileReader-String-filename" class="headerlink" title="FileReader(String filename);"></a>FileReader(String filename);</h4><p>对于读取或者写入流对象的构造函数，以及读写方法，还有刷新关闭功能都会抛出 IOException 或其子类。</p>
<p>所以都要进行处理，或者 throws 抛出，或者 try、catch 处理。</p>
<h4 id="另一个小细节："><a href="#另一个小细节：" class="headerlink" title="*另一个小细节：  *"></a>*<em>另一个小细节：  *</em></h4><p><strong>当指定绝对路径时，定义目录分隔符有两种方式：</strong></p>
<p><strong>1，反斜线 但是一定要写两个。\  new FileWriter(“c:\demo.txt”);</strong></p>
<p><strong>2，斜线  /  写一个即可。 new FileWriter(“c:/demo.txt”);</strong></p>
<h4 id="字符流的缓冲区："><a href="#字符流的缓冲区：" class="headerlink" title="字符流的缓冲区："></a><strong>字符流的缓冲区：</strong></h4><p>缓冲区的出现提高了对流的操作效率。</p>
<p>原理：其实就是将数组进行封装。</p>
<p>对应的对象：</p>
<p>BufferedWriter：</p>
<p>　　特有方法：</p>
<p><strong>newLine（）：跨平台的换行符。</strong></p>
<p>BufferedReader：</p>
<p>　　特有方法：</p>
<p><strong>readLine（）：一次读一行，到行标记时，将行标记之前的字符数据作为字符串返回。当读到末尾时，返回 null。</strong></p>
<p>使用缓冲区对象时，要明确，缓冲的存在是为了增强流的功能而存在，所以在简历缓冲区对象时，要现有流对象存在。</p>
<p>其实缓冲内部就是在使用流对象的方法，只不过加入了数组对数据进行了临时存储，为了提高操作数据的效率。</p>
<p>代码上的体现:</p>
<p><strong>写入缓冲区对象：</strong></p>
<p>// 建立缓冲区对象必须把流对象作为参数传递给缓冲区的构造函数。</p>
<p>BufferedWriter bw=new BufferedWriter（new FileWriter（“abc.txt”））；</p>
<p>bw.write(“abce”);// 将数据写入到了缓冲区。</p>
<p>bw.flush();// 对缓冲区的数据进行刷新。将数据刷到目的地中。</p>
<p>bw.close();// 关闭缓冲区，其实关闭的是被包装在内部的流对象。</p>
<h3 id="二-字节流"><a href="#二-字节流" class="headerlink" title="二. 字节流:"></a><strong>二. 字节流:</strong></h3><p>抽象基类: InputStream，OutputStream。</p>
<p>字节流可以操作任何数据。</p>
<p>注意：字符流使用的数组是字符数组，char[] chs ；</p>
<p>　　　字节流使用的数组是字节数组，byte[] bt ；</p>
<p>FileOutputStream fos=new FileOutputStream(“a.txt”)；</p>
<p>fos.write(“abcde”); // 直接将数据写入到了目的地。</p>
<p>fos.close();// 只关闭资源。</p>
<p>FileInputSteam fls=new FileInputStream(“a.txt”);</p>
<p>//fis.available();// 获取关联的文件字节数。如果文件体积不大，可以这样操作。</p>
<p>byte[]buf=new byte[fis.available()];// 创建一个刚刚好的缓冲区。// 但是这有一个弊端，就是文件过大，大小超出 Jvm 的内容空间时，会内存溢出。</p>
<p>fis.read(buf);</p>
<p>System.out.println(new String(buf));</p>
<p>例子:</p>
<p>　　需求: copy 一个图片。</p>
<p>BufferedInputStream bufis=new BufferedInputStream(new FileInputStream(“1.jpg”));</p>
<p>BufferedOutputStream bufos=new BufferedOutputStream(new FileOutputStream(“2.jpg”));</p>
<p>int by=0;</p>
<p>while(by=bufis.read()!=-1){</p>
<p>　　bufos.write(by);</p>
<p>　　bufos.newLine();</p>
<p>}</p>
<p>bufis.close();</p>
<p>bufos.close();</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结:"></a><strong>小结:</strong></h3><p>目前学习的流对象:</p>
<p>字符流: FileReader  FileWriter  BuffereedReader  BufferedWriter</p>
<p>字节流: FileInputStream  FileOutputStream   BufferedInputStream  BufferedOutputStream</p>
<p>补充：</p>
<ol>
<li>字节流的 read（）方法读取的是一个字节。为什么返回的不是 byte 类型，而是 int 类型呢？</li>
</ol>
<p>因为 read 方法读到末尾时返回的是 - 1，而在所操作的数据中很容易出现连续多个 1 的情况，而连续读到 8 个 1，就是 - 1，导致读取会提前停止。所以将读到的一个字节提升为一个 int 类型的数值，但是只保留原字节，并在剩余二进制位补 0。</p>
<p>具体操作是：byte&amp;255 or byte&amp;0xff</p>
<ol start="2">
<li>对于 write 方法，可以一次写入一个字节，但接收的是一个 int 类型数值。只写入该 int 类型的数值的最低一个字节（8 位）。</li>
</ol>
<p>简单说：<strong>read 方法对读到的数据进行提升，write 对操作的数据进行转换。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>File</tag>
      </tags>
  </entry>
  <entry>
    <title>DataURL, Blob, File, Image 之间的关系与转换</title>
    <url>/2019/11/18/DataURL-Blob-File-Image-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="使用前景："><a href="#使用前景：" class="headerlink" title="使用前景："></a>使用前景：</h4><p><strong><em>移动端上传拍照图片太大，使用 canvas 压缩后 base64=&gt;blob 二进制表单文件 =&gt;ajax-POST 上传</em></strong> <a id="more"></a><img src="https://oscimg.oschina.net/oscnet/45bb5cc130ba93fa7d2365fb81304c75f9a.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// canvas转dataURL：canvas对象、转换格式、图像品质</span><br><span class="line">function canvasToDataURL(canvas, format, quality) &#123;</span><br><span class="line">    return canvas.toDataURL(format||&apos;image/jpeg&apos;, quality||1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// DataURL转canvas</span><br><span class="line">function dataURLToCanvas(dataurl, cb)&#123;</span><br><span class="line">    var canvas = document.createElement(&apos;CANVAS&apos;);</span><br><span class="line">    var ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.onload = function()&#123;</span><br><span class="line">        canvas.width = img.width;</span><br><span class="line">        canvas.height = img.height;</span><br><span class="line">        ctx.drawImage(img, 0, 0);</span><br><span class="line">        cb(canvas);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = dataurl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// image转canvas：图片地址</span><br><span class="line">function imageToCanvas(src, cb)&#123;</span><br><span class="line">    var canvas = document.createElement(&apos;CANVAS&apos;);</span><br><span class="line">    var ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.src = src;</span><br><span class="line">    img.onload = function ()&#123;</span><br><span class="line">        canvas.width = img.width;</span><br><span class="line">        canvas.height = img.height;</span><br><span class="line">        ctx.drawImage(img, 0, 0);</span><br><span class="line">        cb(canvas);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// canvas转image</span><br><span class="line">    function canvasToImage(canvas)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">        img.src = canvas.toDataURL(&apos;image/jpeg&apos;, 1.0);</span><br><span class="line">        return img;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// File/Blob对象转DataURL</span><br><span class="line">    function fileOrBlobToDataURL(obj, cb)&#123;</span><br><span class="line">        var a = new FileReader();</span><br><span class="line">        a.readAsDataURL(obj);</span><br><span class="line">        a.onload = function (e)&#123;</span><br><span class="line">            cb(e.target.result);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// DataURL转Blob对象</span><br><span class="line">    function dataURLToBlob(dataurl)&#123;</span><br><span class="line">        var arr = dataurl.split(&apos;,&apos;);</span><br><span class="line">        var mime = arr[0].match(/:(.*?);/)[1];</span><br><span class="line">        var bstr = atob(arr[1]);</span><br><span class="line">        var n = bstr.length;</span><br><span class="line">        var u8arr = new Uint8Array(n);</span><br><span class="line">        while(n--)&#123;</span><br><span class="line">            u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Blob([u8arr], &#123;type:mime&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Blob转image</span><br><span class="line">    function blobToImage(blob, cb)&#123;</span><br><span class="line">        fileOrBlobToDataURL(blob, function (dataurl)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">            img.src = dataurl;</span><br><span class="line">            cb(img);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// image转Blob</span><br><span class="line">    function imageToBlob(src, cb)&#123;</span><br><span class="line">        imageToCanvas(src, function (canvas)&#123;</span><br><span class="line">            cb(dataURLToBlob(canvasToDataURL(canvas)));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Blob转canvas</span><br><span class="line">    function BlobToCanvas(blob, cb)&#123;</span><br><span class="line">        fileOrBlobToDataURL(blob, function (dataurl)&#123;</span><br><span class="line">            dataURLToCanvas(dataurl, cb);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// canvas转Blob</span><br><span class="line">function canvasToBlob(canvas, cb)&#123;</span><br><span class="line">	cb(dataURLToBlob(canvasToDataURL(canvas)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// image转dataURL</span><br><span class="line">function imageToDataURL(src, cb)&#123;</span><br><span class="line">	imageToCanvas(src, function (canvas)&#123;</span><br><span class="line">		cb(canvasToDataURL(canvas));</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// dataURL转image，这个不需要转，直接给了src就能用</span><br><span class="line">function dataURLToImage(dataurl)&#123;</span><br><span class="line">	var img = new Image();</span><br><span class="line">	img.src = d;</span><br><span class="line">	return img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Blob</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p>hello world!!</p>
]]></content>
  </entry>
</search>
